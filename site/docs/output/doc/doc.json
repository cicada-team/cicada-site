{"kong4-zhi4-fan3-zhuan3-he2-yi1-lai4-zhu4-ru4":{"title":"控制反转和依赖注入","description":"基础教程","author":"imink","group":"ADVANCED","index":[3,0],"url":"kong4-zhi4-fan3-zhuan3-he2-yi1-lai4-zhu4-ru4","toc":[{"id":"kong4-zhi4-fan3-zhuan3-de-hao3-chu3","value":"控制反转的好处"},{"id":"zai4-cicada-dang1-zhong1-de-ying1-yong4","value":"在 Cicada 当中的应用"}],"content":"<pre class=\"hljs\"><code><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-keyword\">export</span> init() {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">register</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">args</span>)</span>{},\n    <span class=\"hljs-attr\">cancel</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">args</span>)</span>{},\n    <span class=\"hljs-attr\">run</span>: <span class=\"hljs-keyword\">this</span>.run(args)\n  }\n}\n<span class=\"hljs-comment\">// container.js</span>\n<span class=\"hljs-keyword\">import</span> A <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'a.js'</span>\n<span class=\"hljs-keyword\">import</span> B <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'b.js'</span>\n<span class=\"hljs-keyword\">const</span> A = A.init()\n<span class=\"hljs-keyword\">const</span> instanceOfB = B.init()\n<span class=\"hljs-keyword\">const</span> instanceOfA = A.register(instanceOfB)\n</code></pre>\n<p>a.js 的 register 需要参数，这就是\b<a href=\"https://en.wikipedia.org/wiki/Dependency_injection\">依赖注入（Dependency Injection）</a>的设计模式，其\b背后的\b思想是控制反转（Inverse of Control）。不论是 Utility 当中的 <code>validation.js</code> 还是 Job 当中的 \b<code>mapBackgroundToState.js</code>，其代码结构都保持高度的统一性，即返回一个对象，该对象具备了一系列方法，但是自己本身不会运行这些暴露的方法。只有在上一层，比如 <code>createBackground.js</code> 当中，这些对象的方法才会被调用。把对象的控制权交给第三方容器，第三方容器统一管理对象的创建和销毁。</p>\n<h2 id=\"kong4-zhi4-fan3-zhuan3-de-hao3-chu3\">控制反转的好处</h2>\n<p>如图所示，在没有第三方容器的情况下，对象 A 的 ru\bn 方法用到了 对象 B 的实例，如果对象 A 要继续运行，必须自己实例化对象B，或者引用对象 B的实例。同样的，对象 C\b 的 c\bancel 方法用到了对象 A 的实例，也必须创立或者引用对象 C。对象 A、C 在各自的方法都需要其他对象的\b参与，正常情况下，如果没有统一的容器来管理，那么对象 A、C 就会实例化其他对象，造成\b冗余（对象 B 被实例化2次）。如果这个时候，涉及到更多的对象，就会造成代码逻辑混乱，难以管理。如果抽象出一层第三方容器，来统一管理每个对象的依赖关系，由该容器来实例化每个对象，我们就可以通过对象引用的方式，方便地运行对象的方法。每个对象只是\b声明了自己的依赖，并未真正运行，而真正的控制权则交给了第三方容器。因而实现了具有依赖关系的对象之间的解耦。</p>\n<h2 id=\"zai4-cicada-dang1-zhong1-de-ying1-yong4\">在 Cicada 当中的应用</h2>\n<p>Cicada 源码中，这个容器就是 <code>connect</code>，每一个被 connect 封装后的组件，都完成了组件方法和属性的复写，有以下4个步骤：</p>\n<ul>\n<li>setupLifeCycle() // 处理注入的声明周期函数</li>\n<li>setupIntercepters() //  处理注入的 interceptor</li>\n<li>setupDefaultListeners() //  处理注入的事件</li>\n<li>registerToContext() //  注册组件状态，包括 background、appearance、stateTree 的注册</li>\n</ul>\n<p>封装后的组件，依然可以无缝配合 React 框架来完成页面的渲染和声明周期的管理，但是具备了更多更负责的能力。</p>\n","githubLink":"githubLikn/src/doc/advanced-topic/dependency-injection.md"},"ru2-he2-kai1-fa1-zi4-ding4-yi4-cha1-jian4":{"title":"如何开发自定义插件","description":"基础教程","author":"imink","group":"ADVANCED","index":[3,1],"url":"ru2-he2-kai1-fa1-zi4-ding4-yi4-cha1-jian4","toc":[{"id":"background-utility","value":"Background Utility"},{"id":"background-job","value":"Background Job"},{"id":"xiao3-jie2","value":"小结"}],"content":"<p>我们已经为 Cicada 提供了自建的一些 Background 插件，既可以作为工具方便用户开发应用，也可以作为案例，便于开发者根据需求开发自己的 Background 插件。整个 \bBackground 分为2种类型，Utility 和 Job。接下来的教程我们将告诉你如何开发自己的 Background 插件。</p>\n<h2 id=\"background-utility\">Background Utility</h2>\n<h3 id=\"dai4-ma3-jie2-gou4\">代码结构</h3>\n<p>一个 Background Utility 必须暴露以下2个方法：</p>\n<ul>\n<li>initialize 用来初始化 Utility，被上层 background 调用</li>\n<li>check 用来确认当前组件是否需要 Cicada 提供对 Utility 的支持，其返回结果是 boolean 类型\n\b</li>\n</ul>\n<h4 id=\"initialize-fang1-fa3\">initialize 方法</h4>\n<p>initialize 是 Utility 实例化的方法，每一个 Utility 的 initialize 方法都有局部变量来保存 stateId 到 Utility 方法的映射关系。这样方便通过 stateId 来获取对应组件的 Utility 方法。此外，register 方法（可选）也可以写在 initialize 当中，方便 Utility 直接获取组件的状态（register 方法的参数和组件自身相关），Utility 如果存在 register 函数，则该函数返回一个 cancelRegister 的函数，用来做一些变量的销毁和清空操作。</p>\n<h2 id=\"background-job\">Background Job</h2>\n<p>我们之前提到过，Background Job 可以理解为根据 Background Utility 自动触发的动作，是用户间接操作导致触发，比如用户点击了勾选框，从而间接导致输入框出现。所以通常来说，Background Job 用来处理更改组件状态（比如显隐，文本显示，样式变化）。目前 Cicada 已经提供的有 visibility （控制显隐）、mapBackgroundToState（更改组件状态）以及 interpolation （控制文本显示）。当然还有更多的使用场景待开发，比如操作日志记录，用户操作收集。接下来的教程会告诉你如何开发一个 Background Job。</p>\n<h3 id=\"dai4-ma3-jie2-gou4-2\">代码结构</h3>\n<p>一个 Background Job 应该暴露如下方法（不可或缺）：</p>\n<ul>\n<li><code>initialize</code> 用来初始化当前 Job，同时返回三个方法供外层的 BackgroundContainer 调用：<code>register</code>, <code>run</code>, <code>handle</code></li>\n<li><code>check</code> 用来确认当前组件是否需要 Cicada 提供对 Job 的支持，其返回结果应该是 boolean 类型，需要注意的是 <code>check</code> 方法的参数即\b Job 的名称，例如如果我们需要某个组件使用显影的 Job，就需要在组件的 prop 上\b添加对应的属性，通常是函数数组。</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;Input visible={[<span class=\"hljs-function\">(<span class=\"hljs-params\">{ stateTree }</span>) =&gt;</span> { <span class=\"hljs-keyword\">return</span> stateTree.get(<span class=\"hljs-string\">'other.flag'</span>)}]} ...otherProps /&gt;\n</code></pre>\n<h3 id=\"initialize-fang1-fa3-2\">initialize 方法</h3>\n<p>我们重点关注 Job 的初始化方法， 它包含了一个局部变量 stateIdToXXXJob 用来保存 stateId 和 Job 方法的映射关系，同时返回了3个函数：<code>register</code>、<code>run</code>、<code>handle</code>。\ninitialize 方法接受的参数为 Backgroun Utility 的实例集合 utilInstances（比如 business，validation）以及 stateTree 和 appearance。这些参数来自上层的 BackgroundContainer。</p>\n<h4 id=\"register\">register</h4>\n<p>\bregister 用来\b\b\b初始化之前提到的局部变量 stateIdToXXXJob，对于一个 Cicada 应用，我们通常只有一个实例化的 Job 或者 Utility，而它们与组件之间的联系是通过 stateId 完成的。同样以 visible Job 为例，</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">register</span>(<span class=\"hljs-params\">stateId, { visible = [] }</span>) </span>{\n  stateIdToVisibleFns[stateId] = visible\n}\n</code></pre>\n<p>\bregister \b接受2个参数，均来自组件本身，<code>stateIdToVisibleFns</code> 只是存贮了 visible 方法而已。真正的运行在 run 函数</p>\n<h4 id=\"run\">run</h4>\n<p>run 只接受一个参数 stateId，用来找到对应的 Job 函数以及组件状态，然后运行 Job 函数，返回处理结果。</p>\n<h4 id=\"handle\">handle</h4>\n<p>handle 接受2个参数，分别是 stateId 和 result，result 即 run 函数的运行结果，\b这里我们可以完成组件的状态更新，通过比如 stateTree 或者 appearance 的 set 方法。</p>\n<h2 id=\"xiao3-jie2\">小结</h2>\n","githubLink":"githubLikn/src/doc/advanced-topic/develop-your-own-playground.md"},"reactlego-zu3-jian4-gui1-fan4":{"title":"React lego 组件规范","description":"react lego specification","author":"imink","group":"ADVANCED","index":[3,2],"url":"reactlego-zu3-jian4-gui1-fan4","toc":[{"id":"an1-zhuang1","value":"安装"},{"id":"gai4-lan3","value":"概览"},{"id":"an4-li4","value":"案例"},{"id":"defaultstatetypes","value":"defaultStateTypes"},{"id":"defaultstate","value":"defaultState"},{"id":"initialize","value":"initialize"},{"id":"interceptors","value":"interceptors"},{"id":"defaultlisteners","value":"defaultListeners"},{"id":"defaultwrappers","value":"defaultWrappers"},{"id":"identifiers","value":"identifiers"},{"id":"render","value":"render"},{"id":"zong3-jie2","value":"总结"}],"content":"<h2 id=\"an1-zhuang1\">安装</h2>\n<p>仓库中提供了 examples。可直接通过以下命令启动查看:</p>\n<pre class=\"hljs\"><code>npm install\nnpm start\n// visit 127.0.0.1/examples/basic 或者 127.0.0.1/examples/wrapper\n</code></pre>\n<p>仓库中提供的 wrap 函数可以直接将 react-lego 组件打包成普通 react 组件进行使用。使用方法参考 example 中的代码。</p>\n<h2 id=\"gai4-lan3\">概览</h2>\n<p>React Lego 组件规范是 Cicada 框架中非常重要的一环。我们认为一个复杂的前端页面是由无数组件构成，这里的组件，可以是 React 写法的组件，也可以是 React Lego 组件。前端引擎通过用户组织的组件，去构建具备了复杂交互、完整状态的页面。与传统后端通过模板渲染前端页面不一样，前端渲染啊的组件化的页面提供了更多的功能来应对各种各样的场景，比如获取一个下拉框的选取状态、触发勾选框的勾选状态来\b更改另一个勾选框的勾选状态。 React Lego 正是后者中的\b一种写法规范。</p>\n<h2 id=\"an4-li4\">案例</h2>\n<p>相比于传统的 React 组件，React Lego 最主要的特点在于: 直接将组件的 state, listener, render 暴露到外部，由外部框架负责创建成 React 组件。一个典型的 Lego 组件例子如下:</p>\n<pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> defaultStateTypes = {<span class=\"hljs-comment\">/* state 的类型声明 */</span>}\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> defaultState = {<span class=\"hljs-comment\">/* 默认的 state */</span>}\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initialize</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 返回一个对象，改对象将作为 instance 参数注入到所有函数中。可将 instance 作为数据缓存</span>\n    <span class=\"hljs-keyword\">return</span> {}\n  }\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> interceptors = [<span class=\"hljs-comment\">/* 声明外部传入的函数类型的属性 */</span>]\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> defaultListeners = {\n    <span class=\"hljs-comment\">// 第一参数为外部框架注入。后面的参数即调用 listener 时传入的参数。</span>\n    onClick({ state, instance }, ...args) {\n      <span class=\"hljs-comment\">// const changedStateValues = ...</span>\n      <span class=\"hljs-comment\">// changedStateValues 只包含变化了的 state 字段</span>\n      <span class=\"hljs-keyword\">return</span> changedStateValues\n    }\n  }\n\n  <span class=\"hljs-keyword\">export</span> defaultWrappers = {\n    <span class=\"hljs-comment\">// 可由外部传入的语义化的子组件</span>\n    Text: <span class=\"hljs-string\">'span'</span>\n  }\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> identifiers = {\n    <span class=\"hljs-comment\">// 例如 Tabs 下的 TabPane。Input 的 Prefix 这种占位符式的组件需要在这里声明</span>\n  }\n\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">{state, children, instance, listeners, wrappers, interceptors}</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  }\n</code></pre>\n<h2 id=\"defaultstatetypes\">defaultStateTypes</h2>\n<p>声明的方式和 react 的 defaultPropTypes 一样。可以直接使用 <code>prop-types</code> 来声明。例如:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> defaultStateTypes = {\n  <span class=\"hljs-attr\">value</span>: PropTypes.string.isRequired\n}\n</code></pre>\n<h2 id=\"defaultstate\">defaultState</h2>\n<p>在 lego 中不再区别 state 和 props，所有会影响到组件渲染的数据，都应该写成 state。state 即可由内部 listener 修改，也可由外部传入。在设计 state 时，应该遵循一下原则:</p>\n<ul>\n<li>state 的各个值之间尽量不要存在依赖关系。如果存在，应该拆成更原子的多个值。或者合并成一个值。</li>\n<li>优化性能的缓存数据应该存在 instance 上。</li>\n</ul>\n<p>注意，state 中不应该包含函数，要由外部传如的函数应该使用 interceptors。</p>\n<h2 id=\"initialize\">initialize</h2>\n<p>组件初始化时调用，放回的对象会贯穿组件的整个生命周期。可以在对象上存放缓存数据。</p>\n<h2 id=\"interceptors\">interceptors</h2>\n<p>当组件需要获取外部传入函数，并且根据函数的返回值再进行渲染或者运算时，应该声明需要的 interceptors 的名字。例如 Upload 组件通常会一个 <code>beforeUpload</code> 函数来判断是否要上传。那么再组件中就应该声明:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> interceptors = [<span class=\"hljs-string\">'beforeUpload'</span>]\n</code></pre>\n<h2 id=\"defaultlisteners\">defaultListeners</h2>\n<p>组件默认的 state 处理函数。参数的第一参数是由外部注入的，一定会包含 state/instance 两个值。剩下的参数即是调用 listener 是传入的参数。返回值应该是变化的 state 键值对。注意，listener 应该为纯函数，其中不应该有 ajax 和其他副作用。例如 Input:</p>\n<pre class=\"hljs\"><code> <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> listeners = {\n   onChange(_, e) {\n     <span class=\"hljs-keyword\">return</span> {  <span class=\"hljs-attr\">value</span>: e.target.value }\n   }\n }\n\n <span class=\"hljs-keyword\">export</span> render({state, listeners}) {\n   <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{state.value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{listeners.onChange}</span> /&gt;</span>\n }\n</span></code></pre>\n<h2 id=\"defaultwrappers\">defaultWrappers</h2>\n<p>组件用来包装自身内容的语义化的标签。可以用来做外部样式的复写，或者多语言支持等。声明的 wrapper 必须是一个标准的 react 组件。以一个简单的文字展示组件为例:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> defaultWrappers = {\n  <span class=\"hljs-attr\">Text</span>: <span class=\"hljs-string\">'span'</span>\n}\n\n<span class=\"hljs-keyword\">export</span> render({ state, wrappers }) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Text</span>&gt;</span>name: <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Text</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{state.name}/</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n</span></code></pre>\n<p>在传统的组件库中，要支持样式的复写，通常是与外部约定 className。要支持多语言通常是在组件内判断外部是否有要传入复写的文字。而通过这种方式，外部框架就能通过传入定制的 Wrapper 来覆盖掉默认的样式甚至文字内容。同时又不需要组件内部了解具体的方案，也不需要繁琐的判断。</p>\n<h2 id=\"identifiers\">identifiers</h2>\n<p>很多组件都需要对外部传入的子组件进行位置的调整，或者根据数据来进行复制。例如 Tabs，通常会把内容包装在 Tabs.TabPane 中。在 lego 中统一将这样的内容包装在声明的 identifier 中。例如 Tabs:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> identifiers = {\n  Pane() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span> }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> render({ state, identifiers, children }) = {\n  <span class=\"hljs-keyword\">const</span> paneChildren = children.find(<span class=\"hljs-function\"><span class=\"hljs-params\">child</span> =&gt;</span> child.type.__base === identifiers.Pane)\n  <span class=\"hljs-keyword\">const</span> panes = state.list.map(<span class=\"hljs-comment\">/*根据数据复制 pane*/</span>)\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{panes}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}\n</code></pre>\n<h2 id=\"render\">render</h2>\n<p>与 react 的 render 函数不同的是，lego 的 render 是个纯函数。它的第一参数应该包含 <code>state children instance listeners wrappers interceptors</code>。</p>\n<h2 id=\"zong3-jie2\">总结</h2>\n","githubLink":"githubLikn/src/doc/advanced-topic/react-lego.md"},"dong4-tai4-xuan4-ran3":{"title":"动态渲染","description":"基础教程","author":"imink","group":"EXAMPLES","index":[2,3],"url":"dong4-tai4-xuan4-ran3","toc":[],"content":"<p>Cicada 的动态渲染是针对通过 config 配置方式写的组件而言的。由于所有配置组件本质上都是一个 JavaScript 对象，只是描述了组件的内部结构和属性，不具备任何渲染的能力。必须要存在一种方法能够检测到配置组件中潜在的新的组件。例如用户想在一个点击一个按钮之后，生成一个新的输入框，如果是配置组件，会写成下面这种形式。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-attr\">children</span>: [{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Button'</span>,\n    <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'1 click to render a dynamic Input'</span>,\n    }),\n    <span class=\"hljs-attr\">listeners</span>: {\n      <span class=\"hljs-attr\">onClick</span>: {\n        <span class=\"hljs-attr\">fns</span>: [{\n          fn({ stateTree }) {\n            stateTree.merge(<span class=\"hljs-string\">'dynamic.config'</span>, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Input'</span> })\n          },\n        }],\n      },\n    },\n  }, {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'DynamicRender'</span>,\n    <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-string\">'dynamic'</span>,\n  }],\n}\n</code></pre>\n<p><code>DynamicRender</code> 是我们定义好的动态渲染组件，专门用来处理不确定的组件变化。<code>stateTree.merge('dynamic.config', { type: 'Input' }</code> 这里用到了 merge 操作，会在 bind 为 dynamic 的组件上生成输入框。由于 config 是用来定义组件结构的，所有 config 当中一旦定义了新组件，就会对应的生成改组件。</p>\n<p>我们再看看 DynamicRender 是如何定义的。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> createDynamicRender <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/createDynamicRender'</span>\n...\nconst DynamicRender = connect(createDynamicRender(\n  applyStateTreeSubscriber(createStateTree),\n  createAppearance,\n  createBackground,\n  backgroundDef,\n), <span class=\"hljs-string\">'DynamicRender'</span>)\n</code></pre>\n<p>经过 <code>createDynamicRender</code> 定义的组件是不具有展示效果的组件，同理，经过 connect 封装后，依然是一个非展示性的组件。我们可以把 dynamicRender 理解成用来生成组件的组件。</p>\n","githubLink":"githubLikn/src/doc/examples/dynamic-render.md"},"demo-jie4-shao4":{"title":"Demo 介绍","description":"针对 cicada.js 的擅长场景，我们制作了5个 demo 用来展示场景的应用，方便用户把玩代码","author":"imink","group":"EXAMPLES","index":[2,0],"url":"demo-jie4-shao4","toc":[{"id":"ruo4-gan1-demo-zhan3-shi4","value":"若干 Demo 展示"},{"id":"shi3-yong4","value":"使用"}],"content":"<h2 id=\"ruo4-gan1-demo-zhan3-shi4\">若干 Demo 展示</h2>\n<p>我们针对 cicada.js 的擅长场景，提供了若干 Demo 展示给用户，便于更好的理解 Cicada</p>\n<ul>\n<li>\n<p><a href=\"todo\">Todo</a> Todo，怎么都不会少的 Todo 应用</p>\n</li>\n<li>\n<p><a href=\"\">\bDynamic Render</a> 通过 config 配置的方式在运行时动态添加组件</p>\n</li>\n<li>\n<p><a href=\"%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81\">Form</a> 标准的表单页面，几乎涵盖了常见的表单验证的所有场景，包括非空校验，联合校验，异步校验，显隐用法</p>\n</li>\n<li>\n<p><a href=\"\">Fragment</a> 展示了复合组件的创建和用法</p>\n</li>\n<li>\n<p><a href=\"%E8%B7%AF%E7%94%B1\">React-router</a> 配合 react-router-dom 实现路由功能</p>\n<p>更多源码写在 pages 下，欢迎尝试</p>\n</li>\n</ul>\n<h2 id=\"shi3-yong4\">使用</h2>\n<pre class=\"hljs\"><code>npm install\nnpm start\nopen http:<span class=\"hljs-comment\">//localhost:8080/pages/{demoName}/index.html</span>\n</code></pre>\n","githubLink":"githubLikn/src/doc/examples/example-intro.md"},"biao3-dan1-yan4-zheng4":{"title":"表单验证","description":"基础教程","author":"imink","group":"EXAMPLES","index":[2,1],"url":"biao3-dan1-yan4-zheng4","toc":[{"id":"zai4-xian4-bian1-ji2-qi4","value":"在线编辑器"},{"id":"fei1-kong1-yan4-zheng4","value":"\b\b非空验证"},{"id":"lian2-he2-xiao4-yan4","value":"联合校验"},{"id":"yi4-bu4-xiao4-yan4","value":"异步校验"},{"id":"zu3-jian4-xian3-yin3","value":"\b组件显隐"},{"id":"zhong4-zhi4","value":"重置"},{"id":"yuan2-ma3","value":"源码"}],"content":"<h2 id=\"zai4-xian4-bian1-ji2-qi4\">在线编辑器</h2>\n<div class='demo' id='demo-2' demo-name='helloWorld' mount-name='helloWorld'></div>\n<p>我们为 Cicada 独立开发了表单验证的扩展功能，以应对复杂的验证场景。在开始之前，我们需要了解 Cicada Render 的使用方法：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 声明全局状态树</span>\n<span class=\"hljs-keyword\">const</span> stateTree = applyStateTreeSubscriber(createStateTree)()\n<span class=\"hljs-comment\">// 声明样式管理器</span>\n<span class=\"hljs-keyword\">const</span> appearance = createAppearance()\n<span class=\"hljs-built_in\">window</span>.stateTree = stateTree\n\n<span class=\"hljs-comment\">// 声明 background 扩展</span>\n<span class=\"hljs-keyword\">const</span> background = createBackground({\n  <span class=\"hljs-attr\">utilities</span>: {\n    <span class=\"hljs-attr\">validation</span>: validationBackground,\n    <span class=\"hljs-attr\">stateTree</span>: stateTreeBackground,\n    <span class=\"hljs-attr\">appearance</span>: appearanceBackground,\n    <span class=\"hljs-attr\">listener</span>: listenerBackground,\n  },\n  <span class=\"hljs-attr\">jobs</span>: {\n    <span class=\"hljs-attr\">mapBackgroundToState</span>: mapBackgroundToStateJob,\n    <span class=\"hljs-attr\">visible</span>: visibleJob,\n  },\n}, stateTree, appearance)\n\nReactDom.render(\n  \b<span class=\"hljs-comment\">// 使用 Cicada Render</span>\n  &lt;Render\n    stateTree={stateTree}\n    appearance={appearance}\n    background={background}\n  &gt;\n  <span class=\"hljs-comment\">// React Lego 组件</span>\n  ...\n  &lt;<span class=\"hljs-regexp\">/ Render&gt;, document.getElementById('root')),\n</span></code></pre>\n<p>一个标准的 Cicada 程序\b包含了上面几个部分。接下来我们会根据 Cicada 提供的 \bValidation 扩展，处理常见的表单验证场景。</p>\n<h2 id=\"fei1-kong1-yan4-zheng4\">\b\b非空验证</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> validators = {\n  notEmpty({ state }) {\n    <span class=\"hljs-keyword\">const</span> isValid = state.value.trim() !== <span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">type</span>: isValid ? <span class=\"hljs-string\">'success'</span> : <span class=\"hljs-string\">'error'</span>,\n      <span class=\"hljs-attr\">help</span>: isValid ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'不能为空'</span>,\n    }\n  }\n}\n...\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>自校验<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span>\n  &lt;C.Input bind=<span class=\"hljs-string\">\"name\"</span> getInitialState={() =&gt; ({ <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'姓名'</span> })} validator={{ <span class=\"hljs-attr\">onChange</span>: [{ <span class=\"hljs-attr\">fn</span>: validators.notEmpty }] }} /&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>由于 Input 是受控组件，即组件的状态由外部引发改变。我们通过组件的默认事件 onChange 来判断是否当前输入框为空。注意到 <code>validator</code> 这个 pr\bop 传入的\b数据结构。</p>\n<p>再看 notEmpty 这个函数，state 作为默认参数可以\b直接访问。\b这里的 state 即为 Input 组件的状态树，它的完整结构如下</p>\n<pre class=\"hljs\"><code></code></pre>\n<p>同样的，notEmpty 返回的是发生改变的组件状态，Validation 扩展\b会判断当前状态是否发生改变，然后显示相应的判断结果。</p>\n<p>对于用户而言，只需要关注验证的规则，而不需要关心验证的原理。</p>\n<h2 id=\"lian2-he2-xiao4-yan4\">联合校验</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> validators = {\n  notDotaAndLoL({ <span class=\"hljs-attr\">stateTree</span>: innerStateTree }) {\n  <span class=\"hljs-keyword\">const</span> isValid = !(innerStateTree.get(<span class=\"hljs-string\">'hobby1.value'</span>) === <span class=\"hljs-string\">'Dota'</span> &amp;&amp; innerStateTree.get(<span class=\"hljs-string\">'hobby2.value'</span>) === <span class=\"hljs-string\">'LOL'</span>)\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: isValid ? <span class=\"hljs-string\">'success'</span> : <span class=\"hljs-string\">'error'</span>,\n    <span class=\"hljs-attr\">help</span>: isValid ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'不能同时喜欢 Dota 和 LOL'</span>,\n  }\n}\n...\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>联合校验<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span>\n  &lt;p&gt;爱好一写Dota，爱好二写LOL就会出错&lt;<span class=\"hljs-regexp\">/p&gt;\n  &lt;C.Input bind=\"hobby1\" getInitialState={() =&gt; ({ label: '爱好一' })} validator={{ onChange: [{ fn: validators.notDotaAndLoL, group: 'hobby' }] }} /</span>&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">C.Input</span> <span class=\"hljs-attr\">bind</span>=<span class=\"hljs-string\">\"hobby2\"</span> <span class=\"hljs-attr\">getInitialState</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> ({ label: '爱好二' })} validator={{ onChange: [{ fn: validators.notDotaAndLoL, group: 'hobby' }] }} /&gt;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>由于我们可以通过 stateTree 获取任意组件的状态，我们可以通过关联2个组件的状态来实现联合校验。确保需要关联的组件具备同样的 validator，比如例子中的 notDotaAndLoL，同时确保 group 一致。TODO</p>\n<h2 id=\"yi4-bu4-xiao4-yan4\">异步校验</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> validators = {\n  notExist({ state }) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> isValid = state.value !== <span class=\"hljs-string\">'万万没想到'</span>\n      setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        resolve({\n          <span class=\"hljs-attr\">type</span>: isValid ? <span class=\"hljs-string\">'success'</span> : <span class=\"hljs-string\">'error'</span>,\n          <span class=\"hljs-attr\">help</span>: isValid ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'数据库里已有'</span>,\n        })\n      }, <span class=\"hljs-number\">300</span>)\n    })\n  },\n}\n...\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>异步校验<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span>\n  &lt;p&gt;输入 万万没想到 会出错&lt;<span class=\"hljs-regexp\">/p&gt;\n  &lt;C.Input bind=\"nickName\" getInitialState={() =&gt; ({ label: '昵称' })} validator={{ onChange: [{ fn: validators.notExist }] }} /</span>&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>notExist 直接返回一个 promise  交给后台 validation 使用。用户无需再定义处理异步的流程。</p>\n<h2 id=\"zu3-jian4-xian3-yin3\">\b组件显隐</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> validators = {\n  notEmpty({ state }) {\n    <span class=\"hljs-keyword\">const</span> isValid = state.value.trim() !== <span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">type</span>: isValid ? <span class=\"hljs-string\">'success'</span> : <span class=\"hljs-string\">'error'</span>,\n      <span class=\"hljs-attr\">help</span>: isValid ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'不能为空'</span>,\n    }\n  },\n}\n...\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>隐藏部分<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span>\n  &lt;C.Checkbox getInitialState={() =&gt; ({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'点我显示下面Input框'</span> })} bind=<span class=\"hljs-string\">\"showAdvance\"</span> /&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">C.Input</span> <span class=\"hljs-attr\">bind</span>=<span class=\"hljs-string\">\"advance\"</span> <span class=\"hljs-attr\">getInitialState</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> ({ label: '高级选项' })} visible={[({ stateTree: stateTreeUtil }) =&gt; {\n    return stateTreeUtil.get('showAdvance.checked') === true\n  }]} validator={{ onChange: [{ fn: validators.notEmpty }] }}\n  /&gt;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n\n</code></pre>\n<p>这个例子当中，我们通过 visibility 这个 utility 扩展控制了输入框的显隐规则。visible 作为 props 被赋值到输入框组件上，visible 本身是一个数组结构，第一个元素返回了 true/false，来告知输入框组件是否需要显隐。我们通过 <code>stateTreeUtil.get('showAdvance.checked')</code> 拿到了勾选框的勾选状态，以此作为显隐规则。</p>\n<h2 id=\"zhong4-zhi4\">重置</h2>\n<pre class=\"hljs\"><code>...\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">C.Button</span> <span class=\"hljs-attr\">getInitialState</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> ({ text: '重置' })} listeners={{ onClick: { fns: [{ fn({ validation }) { validation.reset('') } }] } }} /&gt;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>validation 作为参数传入到 onClick 方法中，通过 <code>validation.reset('')</code> 我们\b重置了所有表单验证组件的状态。事实上，validation 作为 utility 扩展，自身维护了一份当前所有验证组件的状态，并提供了基本的数据操作例如 reset，get，merge 供用户使用。</p>\n<h2 id=\"yuan2-ma3\">源码</h2>\n<p>完整的代码请移步 <code>pages/form/</code> 下</p>\n","githubLink":"githubLikn/src/doc/examples/form-validation.md"},"fu4-he2-zu3-jian4":{"title":"复合组件","description":"基础教程","author":"imink","group":"EXAMPLES","index":[2,5],"url":"fu4-he2-zu3-jian4","toc":[{"id":"shi2-mo2-shi4-fu4-he2-zu3-jian4","value":"什么是复合组件"},{"id":"shi3-yong4-fang1-fa3","value":"使用方法"}],"content":"<h2 id=\"shi2-mo2-shi4-fu4-he2-zu3-jian4\">什么是复合组件</h2>\n<p>符合 React Lego 规范的组件，通常是复用性\b非常高的常规组件，比如输入框，按钮，日期组件。我们把常用的功能写成组件之后，尽可能的维护\b一个数量在合理范围内的组件库，方便随时调用。比如构建在 antdesign 组件之上的 <a href=\"https://github.com/cicada-team/react-lego-antd\">react lego antd</a></p>\n<p>但是随着使用场景的增多，我们\b会遇到单一基础组件无法处理的场景，比如一个模态框需要按钮和输入框的配合使用。这就涉及到了多个基础组件。用户会更希望组件提供者尽可能多的提供多种多样的组件，供他们直接使用。但是对于组件开发者来说，未必是件好事，之前一直依赖的组件最小够用原则就无法遵循。以至于将来组件库会成千上百的增加。</p>\n<p>如果说，我们定义规范，降低组件的开发难度，然后让用户自己去开发这样的组件，效率会高很多。这就是复合组件的初衷：\n复合组件提供由一些基础组件封装成一个高级组件的能力，用户开发的优秀的复合组件，也会被其他用户使用。</p>\n<p>备注：本文的组件写法均为 config 配置方式。</p>\n<h2 id=\"shi3-yong4-fang1-fa3\">使用方法</h2>\n<p>源码在 pages/fragment/index.js</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> convertFragment <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/convertFragment'</span>\n\n<span class=\"hljs-keyword\">const</span> fragments = {\n  <span class=\"hljs-attr\">FullName</span>: {\n    <span class=\"hljs-attr\">linkState</span>: {\n      <span class=\"hljs-attr\">name</span>: {\n        <span class=\"hljs-keyword\">from</span>({ stateTree }) {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${stateTree.get(<span class=\"hljs-string\">'first.value'</span>, <span class=\"hljs-string\">''</span>)}</span>-<span class=\"hljs-subst\">${stateTree.get(<span class=\"hljs-string\">'second.value'</span>, <span class=\"hljs-string\">''</span>)}</span>`</span>\n        },\n        to({ value, stateTree }) {\n          <span class=\"hljs-keyword\">const</span> [firstValue, secondValue] = value.split(<span class=\"hljs-string\">'-'</span>)\n          stateTree.merge(<span class=\"hljs-string\">'first'</span>, { <span class=\"hljs-attr\">value</span>: firstValue })\n          stateTree.merge(<span class=\"hljs-string\">'second'</span>, { <span class=\"hljs-attr\">value</span>: secondValue })\n        },\n        <span class=\"hljs-attr\">stateType</span>: <span class=\"hljs-string\">'string'</span>,\n        <span class=\"hljs-attr\">defaultValue</span>: <span class=\"hljs-string\">'Jane-Doe'</span>,\n      },\n    },\n    <span class=\"hljs-attr\">exposeListener</span>: {\n      <span class=\"hljs-attr\">onFirstNameChange</span>: {\n        <span class=\"hljs-attr\">source</span>: <span class=\"hljs-string\">'children.0'</span>,\n        <span class=\"hljs-attr\">listener</span>: <span class=\"hljs-string\">'onChange'</span>,\n      },\n    },\n    didMount() {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'component did mount'</span>)\n    },\n    <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n      <span class=\"hljs-attr\">first</span>: {\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'defaultFirst'</span>,\n      },\n      <span class=\"hljs-attr\">second</span>: {\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'defaultSecond'</span>,\n      },\n    }),\n    <span class=\"hljs-attr\">config</span>: {\n      <span class=\"hljs-attr\">children</span>: [{\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Input'</span>,\n        <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-string\">'first'</span>,\n        <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'first name'</span>,\n        }),\n      }, {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Input'</span>,\n        <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-string\">'second'</span>,\n        <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'second name'</span>,\n        }),\n      }],\n    },\n  },\n}\n\n<span class=\"hljs-keyword\">const</span> baseComponents = mapValues({ Input, Button }, connect)\n<span class=\"hljs-keyword\">const</span> fragmentComponents = mapValues(fragments,\n  (fragment, name) =&gt; connect(\n    convertFragment(\n      fragment,\n      applyStateTreeSubscriber(createStateTree),\n      createAppearance,\n      createBackground,\n      backgroundDef,\n    ), name,\n  ),\n)\n\nReactDom.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Render</span>\n    <span class=\"hljs-attr\">stateTree</span>=<span class=\"hljs-string\">{stateTree}</span>\n    <span class=\"hljs-attr\">appearance</span>=<span class=\"hljs-string\">{appearance}</span>\n    <span class=\"hljs-attr\">components</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">...baseComponents</span>, <span class=\"hljs-attr\">...fragmentComponents</span> }}\n    <span class=\"hljs-attr\">background</span>=<span class=\"hljs-string\">{createBackground(backgroundDef,</span> <span class=\"hljs-attr\">stateTree</span>, <span class=\"hljs-attr\">appearance</span>)}\n    <span class=\"hljs-attr\">config</span>=<span class=\"hljs-string\">{config}</span>\n  /&gt;</span>,\n  document.getElementById('root'),\n)\n</span></code></pre>\n<p>如上，我们会发现复合组件的结构和普通组件结构不同，多了 linkState 和 exposedListener 两个属性。</p>\n<h3 id=\"linkstate\">linkState</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> fragment = FullName: {\n  <span class=\"hljs-attr\">linkState</span>: {\n    <span class=\"hljs-attr\">name</span>: {\n      <span class=\"hljs-keyword\">from</span>({ stateTree }) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${stateTree.get(<span class=\"hljs-string\">'first.value'</span>, <span class=\"hljs-string\">''</span>)}</span>-<span class=\"hljs-subst\">${stateTree.get(<span class=\"hljs-string\">'second.value'</span>, <span class=\"hljs-string\">''</span>)}</span>`</span>\n      },\n      to({ value, stateTree }) {\n        <span class=\"hljs-keyword\">const</span> [firstValue, secondValue] = value.split(<span class=\"hljs-string\">'-'</span>)\n        stateTree.merge(<span class=\"hljs-string\">'first'</span>, { <span class=\"hljs-attr\">value</span>: firstValue })\n        stateTree.merge(<span class=\"hljs-string\">'second'</span>, { <span class=\"hljs-attr\">value</span>: secondValue })\n      },\n      <span class=\"hljs-attr\">stateType</span>: <span class=\"hljs-string\">'string'</span>,\n      <span class=\"hljs-attr\">defaultValue</span>: <span class=\"hljs-string\">'Jane-Doe'</span>,\n    },\n  },\n</code></pre>\n<p>linkState 是用来完成组件状态映射的。通常我们需要将 m 个基础组件的属性通过映射关系，最终只暴露出 n &lt; m 个属性，这里面的映射关系就是在 linkState 里面完成的。<code>name</code> 里面包含了 <code>from</code> 和 <code>to</code> 两个函数，其中 <code>from</code> 代表内部映射属性到外部属性，如图例子，我们把 first name 和 last name \b组合在一起。 <code>to</code> 代表外部属性映射到内部属性，我们把 full name 拆分成 first name 和 last name。其中暴露到外部的属性是 string 类型，默认值为 Jane-Doe。</p>\n<h3 id=\"exposedlistener\">exposedListener</h3>\n<pre class=\"hljs\"><code>exposeListener: {\n  <span class=\"hljs-attr\">onFirstNameChange</span>: {\n    <span class=\"hljs-attr\">source</span>: <span class=\"hljs-string\">'children.0'</span>,\n    <span class=\"hljs-attr\">listener</span>: <span class=\"hljs-string\">'onChange'</span>,\n  },\n},\n</code></pre>\n<p><code>exposedListener</code> 是复合组件唯一暴露的监听事件，你可以添加\b多个监听事件实现更多交互。如例所示，当前组件下暴露了一个 onChange 事件 <code>onFirstNameChange</code>，其中包含了2个属性：<code>source</code> 和 <code>listener</code>，source 指的是原基础组件，这里的 children.0 就是该组件下的第一个输入框组件，listener 代表该输入框组件的监听事件 onChange。</p>\n<h3 id=\"qi2-ta1-shu3-xing4\">其他属性</h3>\n<p>复合组件的其他属性和写一般\b组件一样，比如 config 用来定义组件的结构，getInitialState 用来获取初始状态。</p>\n<h3 id=\"zuo4-wei2-component-chuan2-ru4-render-han2-shu4\">作为 component 传入 Render 函数</h3>\n<p>复合组件和其他基础组件一样，也需要经过 conect 封装才能被 Render 函数正常使用。但在此之前，我们需要调用 createFragment 来封装写好的复合组件。</p>\n","githubLink":"githubLikn/src/doc/examples/frament.md"},"lu4-you2":{"title":"路由","description":"基础教程","author":"imink","group":"EXAMPLES","index":[2,1],"url":"lu4-you2","toc":[{"id":"shi3-yong4","value":"使用"}],"content":"<p>Cicada 支持配合使用 <a href=\"https://github.com/ReactTraining/react-router\">react-router-dom</a> 来完成路由操作。\n我们推荐使用 browserRouter 作为默认的 Router，以便完全利用到 HTML5 的 history API。\n需要注意的是，Cicada 的 Render 组件需要嵌套在 Router 组件内部。</p>\n<h2 id=\"shi3-yong4\">使用</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> {\n  HashRouter <span class=\"hljs-keyword\">as</span> Router,\n  Route,\n  Link,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-router-dom'</span>\n...\nReactDom.render(\n  &lt;Router&gt;\n    &lt;Render\n      stateTree={stateTree}\n      appearance={appearance}\n      background={createBackground({}, stateTree, appearance)}\n    &gt;\n      &lt;div&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&lt;Link to=\"/\"&gt;Input&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to=\"/button\"&gt;Button&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;hr /&gt;\n        &lt;Route exact path=\"/\" component={Input} /&gt;\n        &lt;Route path=\"/button\" component={Button} /&gt;\n      &lt;/div&gt;\n    &lt;/Render&gt;\n  &lt;/Router&gt;,\n    document.getElementById('root'),\n)\n\n</code></pre>\n","githubLink":"githubLikn/src/doc/examples/react-router.md"},"todo-list":{"title":"Todo List","description":"基础教程","author":"imink","group":"EXAMPLES","index":[2,5],"url":"todo-list","toc":[{"id":"ru4-kou3-wen2-jian4-indexjs","value":"入口文件 index.js"},{"id":"scope-de-ying1-yong4-todolist-zu3-jian4","value":"\bScope 的应用 - TodoList 组件"},{"id":"todo-zu3-jian4","value":"Todo 组件"}],"content":"<p>我们接下来通过一个简单的 todo 应用来了解如何实现组件的动态创建，以及如何利用 appearance 和 visibility job 来控制筛选和样式的变化。</p>\n<h2 id=\"ru4-kou3-wen2-jian4-indexjs\">入口文件 index.js</h2>\n<p>加载相关组件，注意这里有我们自己写好的复合组件，TodoList 和 Todo</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> C = mapValues({ Input, Checkbox, TodoList, Todo, Button }, connect)\n\n<span class=\"hljs-keyword\">const</span> background = createBackground({\n  <span class=\"hljs-attr\">utilities</span>: {\n    <span class=\"hljs-attr\">validation</span>: validationBackground,\n    <span class=\"hljs-attr\">stateTree</span>: stateTreeBackground,\n    <span class=\"hljs-attr\">appearance</span>: appearanceBackground,\n    <span class=\"hljs-attr\">listener</span>: listenerBackground,\n    <span class=\"hljs-attr\">business</span>: businessBackground,\n  },\n  <span class=\"hljs-attr\">jobs</span>: {\n    <span class=\"hljs-attr\">mapBackgroundToState</span>: mapBackgroundToStateJob,\n    <span class=\"hljs-attr\">visible</span>: visibleJob,\n  },\n}, stateTree, appearance)\n\n</code></pre>\n<p>\bUnique key 用作循环生成的子组件的 key</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> globalKey = <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUniqueKey</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">String</span>(globalKey++)\n}\n</code></pre>\n<p>接下来是一系列 stateTree 和 business 操作的方法</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 新增一个 todo </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addOne</span>(<span class=\"hljs-params\">{ stateTree: innerStateTree, business }</span>) </span>{\n  <span class=\"hljs-comment\">// reset showFlag</span>\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'All'</span>)\n  <span class=\"hljs-keyword\">const</span> items = innerStateTree.get(<span class=\"hljs-string\">'todoList.items'</span>).slice()\n  <span class=\"hljs-keyword\">const</span> key = createUniqueKey()\n  <span class=\"hljs-keyword\">const</span> todoInput = stateTree.get(<span class=\"hljs-string\">'todoInput.value'</span>)\n  items.push({ key, <span class=\"hljs-attr\">todo</span>: { <span class=\"hljs-attr\">text</span>: todoInput } })\n  stateTree.merge(<span class=\"hljs-string\">'todoList.items'</span>, items)\n}\n<span class=\"hljs-comment\">// 完成某个 todo，注意这里用到了 merge，局部修改组件的某个属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">markCompleted</span>(<span class=\"hljs-params\">{ state, stateTree: innerStateTree, statePath }</span>) </span>{\n  innerStateTree.merge(statePath, { <span class=\"hljs-attr\">completed</span>: state.completed !== <span class=\"hljs-literal\">true</span> })\n}\n<span class=\"hljs-comment\">// todo 的显隐规则，判断全局的 showFlag</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showVisible</span>(<span class=\"hljs-params\">{ state, business }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flag = business.get(<span class=\"hljs-string\">'showFlag'</span>)\n  <span class=\"hljs-keyword\">if</span> (flag === <span class=\"hljs-string\">'All'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-keyword\">if</span> (flag === <span class=\"hljs-string\">'Completed'</span>) {\n    <span class=\"hljs-keyword\">if</span> (state.completed === <span class=\"hljs-literal\">true</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n  <span class=\"hljs-keyword\">if</span> (flag === <span class=\"hljs-string\">'NotCompleted'</span>) {\n    <span class=\"hljs-keyword\">if</span> (state.completed === <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n<span class=\"hljs-comment\">// 标记所有的 todo 已完成</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toggleAllCompleted</span>(<span class=\"hljs-params\">{ stateTree: innerStateTree, business }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> items = innerStateTree.get(<span class=\"hljs-string\">'todoList.items'</span>).slice()\n  <span class=\"hljs-keyword\">const</span> newItems = items.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> todo = item.todo\n    todo.completed = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">return</span> {\n      todo,\n      <span class=\"hljs-attr\">key</span>: item.key,\n    }\n  })\n  innerStateTree.merge(<span class=\"hljs-string\">'todoList.items'</span>, newItems)\n  <span class=\"hljs-comment\">// reset showFlag</span>\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'All'</span>)\n}\n<span class=\"hljs-comment\">// 下面三个方法分别对应显隐按钮</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showCompleted</span>(<span class=\"hljs-params\">{ business }</span>) </span>{\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'Completed'</span>)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showNotCompleted</span>(<span class=\"hljs-params\">{ business }</span>) </span>{\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'NotCompleted'</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showAll</span>(<span class=\"hljs-params\">{ business }</span>) </span>{\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'All'</span>)\n}\n\n</code></pre>\n<p>接下来就是整个页面的结构，首先一个输入框用来输入 todo，下方是 todo list 展示区，最后一排是操作区。</p>\n<pre class=\"hljs\"><code>ReactDom.render(\n  &lt;Render\n    stateTree={stateTree}\n    appearance={appearance}\n    background={background}\n  &gt;\n    &lt;div&gt;\n      &lt;C.Input bind=\"todoInput\" getInitialState={() =&gt; ({ label: '任务' })} /&gt;\n      &lt;C.Button getInitialState={() =&gt; ({ text: '添加' })} listeners={{ onClick: { fns: [{ fn: addOne }] } }} /&gt;\n      &lt;C.TodoList bind=\"todoList\"&gt;\n        &lt;C.Todo\n          bind=\"todo\"\n          getInitialState={() =&gt; ({\n            text: 'task',\n            completed: false,\n          })}\n          listeners={{\n            onTodoClick: {\n              fns: [{\n                fn: markCompleted,\n              }],\n            },\n          }}\n          visible={[showVisible]}\n        /&gt;\n      &lt;/C.TodoList&gt;\n      &lt;C.Button getInitialState={() =&gt; ({ text: '已完成' })} listeners={{ onClick: { fns: [{ fn: showCompleted }] } }} /&gt;\n      &lt;C.Button getInitialState={() =&gt; ({ text: '未完成' })} listeners={{ onClick: { fns: [{ fn: showNotCompleted }] } }} /&gt;\n      &lt;C.Button getInitialState={() =&gt; ({ text: '全部' })} listeners={{ onClick: { fns: [{ fn: showAll }] } }} /&gt;\n      &lt;C.Button bind=\"show\" getInitialState={() =&gt; ({ text: '标记全部已完成' })} listeners={{ onClick: { fns: [{ fn: toggleAllCompleted }] } }} /&gt;\n    &lt;/div&gt;\n  &lt;/Render&gt;,\n  document.getElementById('root'),\n)\n</code></pre>\n<h3 id=\"business-he2-statetree\">business 和 stateTree</h3>\n<p>有人会发现，上面的代码中，我们有时候会用到 stateTree，有时候会用到 business。在 Cicada 中，这两个状态容器都具备了消息订阅的功能，但是 stateTree 只能\b存储组件的状态，对于非组件状态/非 UI 数据，例如逻辑数据或者业务相关的数据，我们就需要用到了 business 来承担原本是 stateTree 的工作。这么做是为了保证 stateTree 数据的纯洁度，避免和业务数据产生污染。</p>\n<h2 id=\"scope-de-ying1-yong4-todolist-zu3-jian4\">\bScope 的应用 - TodoList 组件</h2>\n<p>直接看 TodoList/index.js 的 render 方法，这里我们用到了 Cicada 自带的 Scope 组件，用来子组件动态创建， Scope 组件的属性 relativeChildStatePath 定义了如何对组件的 statePath 命名，子组件通过 <code>React.cloneElement</code> 来生成。 \u001c</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Scope <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/component/Scope'</span>\n...\nexport <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">{ state, children }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> style = {\n    <span class=\"hljs-attr\">display</span>: state.inline ? <span class=\"hljs-string\">'inline-block'</span> : <span class=\"hljs-string\">'block'</span>,\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"repeat-wrapper\"</span>&gt;</span>\n      {state.items.map((_, index) =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Scope</span> <span class=\"hljs-attr\">relativeChildStatePath</span>=<span class=\"hljs-string\">{</span>`<span class=\"hljs-attr\">items.</span>${<span class=\"hljs-attr\">index</span>}`} <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{index}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"repeat-item\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{style}</span>&gt;</span>\n            {Children.map(children, child =&gt; React.cloneElement(child, {}))}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Scope</span>&gt;</span>\n      ))}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}\n</code></pre>\n<p>我们再回过头来看 <code>addOne()</code> 这个方法, 首先拿到所有组件items，再\b push 新的 todo 到 items。注意我们这里用到了 merge 方法，因为我们只是新增了 todo 的属性，其他属性例如 completed 会被自动添加。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 新增一个 todo </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addOne</span>(<span class=\"hljs-params\">{ stateTree: innerStateTree, business }</span>) </span>{\n  <span class=\"hljs-comment\">// reset showFlag</span>\n  business.set(<span class=\"hljs-string\">'showFlag'</span>, <span class=\"hljs-string\">'All'</span>)\n  <span class=\"hljs-keyword\">const</span> items = innerStateTree.get(<span class=\"hljs-string\">'todoList.items'</span>).slice()\n  <span class=\"hljs-keyword\">const</span> key = createUniqueKey()\n  <span class=\"hljs-keyword\">const</span> todoInput = stateTree.get(<span class=\"hljs-string\">'todoInput.value'</span>)\n  items.push({ key, <span class=\"hljs-attr\">todo</span>: { <span class=\"hljs-attr\">text</span>: todoInput } })\n  stateTree.merge(<span class=\"hljs-string\">'todoList.items'</span>, items)\n}\n</code></pre>\n<h2 id=\"todo-zu3-jian4\">Todo 组件</h2>\n<p>Todo 组件就相对简单了。只需要将父级传过来的 prop 展示出来就可以。加上一些逻辑判断，比如 text decoration。需要注意的是，不要忘记定义默认值。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> Todo = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ onTodoClick, completed, text }</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onTodoClick}</span>\n    <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n      <span class=\"hljs-attr\">textDecoration:</span> <span class=\"hljs-attr\">completed</span> ? '<span class=\"hljs-attr\">line-through</span>' <span class=\"hljs-attr\">:</span> '<span class=\"hljs-attr\">none</span>',\n    }}\n  &gt;</span>\n    {text}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n)\n</code></pre>\n","githubLink":"githubLikn/src/doc/examples/todo-app.md"},"shu4-ju4-liu2-he2-quan2-ju2-zhuang4-tai4-shu4":{"title":"数据流和全局状态树","description":"Nothing to see here","group":"HOW IT WORKS","index":[1,4],"url":"shu4-ju4-liu2-he2-quan2-ju2-zhuang4-tai4-shu4","toc":[{"id":"ru2-he2-bao3-zheng4-jian3-jie2-you3-xiao4-de-zhuang4-tai4-shu4-jie2-gou4","value":"如何保证简洁有效的状态树结构"},{"id":"zhuang4-tai4-shu4-ru2-he2-shi2-xian4-geng1-xin1-he2-bian4-hua4-de","value":"状态树如何实现更新和变化的"},{"id":"tong1-guo4-shu4-ju4-lu4-jing4-statepath-huo4-qu3-shu4-ju4","value":"通过数据路径 statePath 获取数据"}],"content":"<p>如何管理网页的状态（包括 UI 状态以及逻辑数据）一直以来是很多前端框架非常关注的部分。React Flux 提出的单向数据流或者 Angular 以及 Vuejs 提出的\b双向绑定本质上也是为了更好的管理网页的状态。一个常见的例子是，用户点击 Check 勾选框，页面会展现新的组件。这里页面的 UI 状态和内部逻辑产生了联系，假如这个勾选框和页面上的另外一个勾选框相关联，只有同时满足这两个勾选框同时勾选，才能展现新的组件，那么我们就必须考虑到新的勾选框的状态。以此类推，这种涉及到多个组件状态的更新触发新的组件的显隐规则的场景是非常常见的。\b这种情况下，\b状态树必须全局地意识到每个组件状态的变化，才能保证\b\b彼此状态的关联性。所以 Cicada 采用了一个全局的状态树 stateTree 来统一管理页面每一个组件的状态变化，换句话说，每个组件的数据结构决定了全局状态树的结构。</p>\n<h2 id=\"ru2-he2-bao3-zheng4-jian3-jie2-you3-xiao4-de-zhuang4-tai4-shu4-jie2-gou4\">如何保证简洁有效的状态树结构</h2>\n<p>我们\b既然让状态树和组件紧密关联，那么这个事先定义好的全局状态树的数据结构自然由 Cicada 引擎来定义和实现了。用户无需关心如何定义状态树，而只需要关注到组件与组件之间如何实现关联就可以了。这听起来似乎非常难懂，有人会问到如果连用户都不知道状态树的数据结构，那又怎么能够触发相应的变化呢？这要归功于 React Lego 的组件规范\b。符合 <a href=\"https://github.com/cicada-team/react-lego\">React Lego 规范</a>的组件在声明以及渲染的时候，保证了一致的数据结构。\b框架层面的引擎能够完全感知组件的每一个状态属性和暴露的监听事件，并通过状态树来初始化和管理。了解 React Lego 规范的用户，也就知道如何通过框架提供的\b API 来实现组件状态的更新和变化。</p>\n<h2 id=\"zhuang4-tai4-shu4-ru2-he2-shi2-xian4-geng1-xin1-he2-bian4-hua4-de\">状态树如何实现更新和变化的</h2>\n<p>状态树 stateTree 在代码当中，通过 <code>const stateTree = applyStateTreeSubscriber(createStateTree)()</code> 来声明，这是一个高阶函数，createStateTree() 的返回结果作为参数被 applyStateTreeSubscriber 来执行。</p>\n<p>我们先看 createStateTree() 这个方法。它主要完成了2个操作：</p>\n<ol>\n<li>提供一个树状的数据保存功能。这个树状的数据理论上应该和 Render 渲染的组件数据结构保持一致。但是这个保障是需要由组件和正确的用户代码来保障，也就是 <a href=\"\">React Lego 规范</a></li>\n<li>提供深度合并，自动修复，重置等数据功能。它在其中注册了组件渲染时的初始值(这个值里包含了用户设置的值)和组件的真实初始值，所以能提供重置功能。</li>\n</ol>\n<p>\b第二个操作实现了类似数据库的基本操作方法，为用户省下大量数据处理的操作，比如 getStateById(), 通过组件 ID 来获取组件状态。我们在组件初始化的时候，为组件赋予了一个全局唯一标识符 unique state id，来关联组件和与之对应的状态数据。</p>\n<p>最后，createStateTree() 会返回一个对象，这个对象包含了具备数据库基本操作方法以及一个注册函数。到此为止，这个全局状态树只是具备了数据的储存和读写功能，依然不具备最关键的事件监听机制。我们回过头来再看<code>const stateTree = applyStateTreeSubscriber(createStateTree)()</code>，这里的 applyStateTreeSubscriber 实际上封装了 createStateTree 返回的对象，使最终的状态树具备了了精确监听组件的的能力。和绝大多数前端框架所具备的数据监听能力一样，Cicada 内部实现了一个消息订阅者模式，被应用在了 applyStateTreeSubscriber 里面。每当状态树发生数据操作的时候（比如 set，merge，reset 等），\b状态树会首先检查和当前状态相关联的事件（比如某个组件的显隐），如果找到相应的事件，就先运行相应事件。那么 Cicada 是如何知道某个状态和关联事件呢：通过状态树的注册函数。</p>\n<p>要注意到整个\b<code>const stateTree = applyStateTreeSubscriber(createStateTree)()</code> 仅仅是状态树的声明，使状态树具备了以上这些能力。真正实现把组件和状态树关联起来的，是在渲染函数 Render 里完成的。</p>\n<h2 id=\"tong1-guo4-shu4-ju4-lu4-jing4-statepath-huo4-qu3-shu4-ju4\">通过数据路径 statePath 获取数据</h2>\n<p>我们知道存在一个全局的树型数据，保存了所有组件的数据，数据路径 statePath 就是用来标识当前数据是在全局状态树上的哪一个位置。每个 React Lego 组件都有 bind 的属性，用来唯一标示当前组件，例如 <code>&lt;Input bind=&quot;userInput&quot; /&gt;</code>，那么当前 Input 组件的所有数据/状态可以通过 <code>stateTree.get('userInput')</code> 获取，\bInput 输入框的值可以通过 <code>stateTree.get(userInput.value)</code> 获取。如果用户没有写 bind，Cicada 会默认给用户生成唯一标识符。</p>\n<p>需要注意的是， 当组件写在 Table/Collapse/Repeat/Tabs 等会根据数据进行循环渲染的组件下时, 这些组件会产生一个 Scope， 使得它下面所有组件的数据都是绑在这个组件的数据的某一个字段上，而不再是 stateTree 的根上。例如</p>\n<pre class=\"hljs\"><code>&lt;Table bind=<span class=\"hljs-string\">'userTable'</span> &gt;\n  &lt;Table.Column&gt;\n    &lt;Input bind='userInput' /&gt;\n  &lt;/ Table.Column&gt;\n&lt;/ Table&gt;\n</code></pre>\n<p>那么 Input 组件的 statePath 为 \b<code>userTable.list.0.userInput</code>, 其中0是 Input 组件的顺序，我们在 EXAMPLE 中会有更详细的解释，以及具体 Scope 该如何使用。</p>\n","githubLink":"githubLikn/src/doc/how-it-works/\bglobal-state-tree.md"},"she4-ji4-li3-nian4":{"title":"设计理念","description":"Nothing to see here","group":"HOW IT WORKS","index":[1,1],"url":"she4-ji4-li3-nian4","toc":[{"id":"wei2-shi2-mo2-yao4-yong4-cicada","value":"为什么要用 Cicada？"},{"id":"statetree-he2-appearance","value":"StateTree 和 Appearance"},{"id":"backgroundutil-he2-job","value":"Background：Util 和 Job"},{"id":"he2-qi2-ta1-kuang4-jia4-bi3-jiao4","value":"和其他框架比较"}],"content":"<h2 id=\"wei2-shi2-mo2-yao4-yong4-cicada\">为什么要用 Cicada？</h2>\n<h3 id=\"shu4-ju4-qu1-dong4\">数据驱动</h3>\n<p>在数据驱动的大背景下，前端应用框架的问题实际上只有一个：数据管理。不论是 React 还是 Redux，都提出了自己对数据管理的概念，React 的组件之间通过 prop 和 state 来实现数据通信，最后利用 Render 来渲染变化的页面。Redux 提出了 action，reducer， store 的概念，并且让数据永远保持单向的通信方式，从而定义了一套数据通信的规范。这里的数据，既可以是组件数据（包括组件的状态和属性，比如输入框的 value、placeholder），也可以是业务数据，而管理既包括如何保存数据，也包括以何种方式让用户来读写数据。我们这里定义好了数据管理对框架的需求之后，就需要知道一个框架该如何更好的和数据打交道。</p>\n<p>我们从业务的角度出发，来探讨数据管理对框架开发的需求的上限和下限：</p>\n<ul>\n<li>下限，无非就是最简单的「详情页」和「列表页」，这里只是利用到了数据的展示功能，框架拿到数据后，前端页面该如何更好看的呈现数据。</li>\n<li>上限，由于前端开发往往是渐进式的开发，我们永远无法知道接下来需求对前端开发提出了怎样的挑战和考验。最好的解决办法就是，在可见的范围内，考虑到未来会发生的情况。对于框架开发的上限而言，应该就是数据的动态设置和获取了。例如我们用 ajax 从后端请求数据，就需要知道数据是以何种结构获取。这种结构是已知的并且可预见的。</li>\n</ul>\n<p>由上，我们可以联想到业务当中最复杂的业务场景，来了解数据具体是如何和框架产生联系的：</p>\n<ul>\n<li>最复杂的业务场景通常包括了大量的交互细节，例如组件状态要和权限结合(例如 按钮的 disable 状态)、组件要根据需求动态显示或隐藏，表单的校验，异步状态的提示或管理(例如发送请求后，按钮上出现loading)。</li>\n<li>除了组件数据，还有大量的业务数据要管理，并且是其中有很多联动关系。例如在云计算控制台里面有 ECS、LBS 等概念，ECS 和 LBS 有关联关系，ECS如果改名了。不仅要更新ECS自己的详情显示，还要自动更新关联的LBS的显示等。</li>\n</ul>\n<p>我们把数据按使用场景来区分，就得到了和交互紧密相关的组件数据（比如 display 属性，字体颜色属性），以及和业务本身相关的业务数据（通常用来处理前端页面的交互逻辑）。我们来看下面一段代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 用户点击按钮，发送 ajax 请求到后台，直到数据返回之前，按钮属于不可使用状态（disabled）</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">submitForm</span>(<span class=\"hljs-params\">{ stateTree }</span>)</span>{\n  stateTree.set(<span class=\"hljs-string\">'submit'</span>, {<span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">true</span>}) <span class=\"hljs-comment\">// 为了防止重复提交</span>\n  ajax({\n    <span class=\"hljs-attr\">url</span> : <span class=\"hljs-string\">'xxx'</span>,\n    <span class=\"hljs-attr\">data</span>: {\n      <span class=\"hljs-attr\">name</span>: stateTree.get(<span class=\"hljs-string\">'name'</span>).value,\n      <span class=\"hljs-attr\">password</span>: stateTree.get(<span class=\"hljs-string\">'password'</span>).value\n    }\n  }).finally(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      stateTree.set(<span class=\"hljs-string\">'submit'</span>, {<span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">false</span>})\n  })\n}\n</code></pre>\n<p>是不是同时处理了组件数据（ Button 的 disabled 属性）又处理了业务数据（拿到了 name 和 password）？如果按照 React 组件化的思想来理解这段代码，它实现了最小组件单元 Button 的目标：触发 ajax =&gt; 拿到数据 =&gt; 修改状态，非常直观易懂的设计。但是我们回过头来看前面对于数据的分类，这段代码既处理了业务逻辑又处理了渲染逻辑，当项目到了后期变得膨胀和复杂起来，代码非常不利于维护和测试。</p>\n<h3 id=\"jian4-li4-shu4-ju4-yuan2-dao4-zu3-jian4-shu4-ju4-de-ying4-she4-guan1-xi4\">建立数据源到组件数据的映射关系</h3>\n<p>再回到上面案例当中的交互细节：当用户按下 Button 之后，发送请求，Button 就设置为 disable true，一旦有响应返回，就设置为 disabled 为 false。我们会发现，Button 的 disabled 属性实际上和网络请求紧密关联的！他们之前存在一种映射关系，即网络请求的状态直接影响了 Button 的 disabled 属性的变化。</p>\n<p>我们再推广到更多的交互场景：</p>\n<ul>\n<li>异步状态控制，如上面 button 在发请求时要设为 disable 防止重复提交</li>\n<li>权限控制</li>\n<li>表单验证状态</li>\n</ul>\n<p>不难发现，几乎所有的交互都一定是又内部某个状态的变化而引发的，比如 Input 组件输入为空，就一定会有非空的报错提醒，又或者当用户不具有管理员的权限的时候，在用户管理界面就不会出现删除用户的按钮。</p>\n<p>这种映射关系可以写成：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 发送 ajax</span>\najax(<span class=\"hljs-string\">'login'</span>, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'xxx'</span>, <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">'xxx'</span>})\n\n<span class=\"hljs-comment\">// ajaxStates 由框架提供，保存着所有的ajax 状态</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapAjaxToButton</span>(<span class=\"hljs-params\">{ajaxStates}</span>)</span>{ \n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">disabled</span>: ajaxStates.login === <span class=\"hljs-string\">'pending'</span>\n  }\n}\n</code></pre>\n<p>总结来说，我们得到了下面几个概念之间的关系</p>\n<p><img src=\"https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/18015/a9273a89e82f6c95.png\" alt=\"RatpXXxLIEZaejNQynnK.png\"></p>\n<p>有了上图的关系，我们的框架就能意识到这种映射关系的存在，而用户则无需考虑到数据源和组件数据之间的是如何相互影响的，只需要定义好映射关系和触发规则，就可以实现组件数据和业务数据之间的分离。</p>\n<h3 id=\"zu3-jian4-shu4-ju4-he2-zhuan1-you3-ling3-yu4-shu4-ju4-fen1-li2\">组件数据和专有领域数据分离</h3>\n<p>我们到现在还没有提到组件数据的设计，正如前面所说，所有的组件状态是由应用框架保存的。例如，一个 Button 组件所具备的属性有：text、size、loading、type、disable，每一个属性都对应着组件样式的变化和交互的变化。如果框架能够全面意识到组件所具备的属性，就能够灵活的根据业务逻辑去触发相应的交互变化。但是这和我们现实中常见的经验相悖。现实中的组件通常是数据、行为、渲染逻辑三部分写在一起，使用 class 或者工厂方法来创建。如果是全面由框架接管，则应该打散，全部写成声明式。于是我们提出了 <a href=\"\">React Lego</a> 组件规范。一个符合 React Lego 规范的 Button 组件应该写成下面这种形式：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> TYPES = [<span class=\"hljs-string\">'normal'</span>, <span class=\"hljs-string\">'primary'</span>, <span class=\"hljs-string\">'dashed'</span>, <span class=\"hljs-string\">'ghost'</span>]\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getDefaultState = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">size</span>: SIZES[<span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">type</span>: TYPES[<span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-string\">''</span>,\n})\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> stateTypes = {\n  <span class=\"hljs-attr\">text</span>: PropTypes.string,\n  <span class=\"hljs-attr\">size</span>: PropTypes.oneOf(SIZES),\n  <span class=\"hljs-attr\">loading</span>: PropTypes.bool,\n  <span class=\"hljs-attr\">type</span>: PropTypes.oneOf(TYPES),\n  <span class=\"hljs-attr\">disabled</span>: PropTypes.bool,\n  <span class=\"hljs-attr\">icon</span>: PropTypes.string,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> defaultListeners = {\n  <span class=\"hljs-attr\">onClick</span>: keep,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">{ state, listeners }</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> {<span class=\"hljs-attr\">...omit</span>(<span class=\"hljs-attr\">state</span>, '<span class=\"hljs-attr\">text</span>')} {<span class=\"hljs-attr\">...listeners</span>}&gt;</span>{state.text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span></span>\n}\n</code></pre>\n<p>具体的每个方法和属性的用法我们不在这里一一描述，但从代码中可以看出，与传统的 React 组件不同，React Lego 组件几乎把所有的方法和属性都暴露给了框架本身，由框架去统一管理组件的生命周期和内部状态。而组件本身，不保存任何状态。</p>\n<p>对于专有领域数据，我们可以理解成非组件数据外的所有数据，这包括表单数据状态源、异步状态数据源、业务数据源等等。我们在下面的子标题「Background：Util 和 Job」，会介绍专有数据源。</p>\n<p><img src=\"https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/18015/ceeda11b4b7108a4.png\" alt=\"fYMQMhvVgwPrfyFVbugp.png\"></p>\n<p>最后，我们就得到了上面的关系图。</p>\n<h2 id=\"statetree-he2-appearance\">StateTree 和 Appearance</h2>\n<p>stateTree 即全局的组件数据源，在一个 Cicada 应用中，通常只存在一个 stateTree 用来保存所有的 React Lego 组件，前面我们已经提到了数据源分开的好处，而作为最核心的数据源，stateTree 具有统一的格式来存储组件状态。stateTree 自身也具备了常见的 getter 和 setter 操作，直接操作组件数据。</p>\n<p>所谓术业有专攻，我们针对组件的样式，抽象了一层 appearance 数据源出来，单独处理需要更改样式的组件。</p>\n<h2 id=\"backgroundutil-he2-job\">Background：Util 和 Job</h2>\n<p>任何一个有一定复杂度、会持续增长的应用最重视的，其实并不是开发速度，而是可维护性和可扩展性。 这也是框架设计者们摆在首位的事情。可扩展性的好坏取决于框架的扩展机制。在我们的上面的设计中需要扩展的有两部分，组件和功能。组件的扩展可以通过允许用户提交自定义组件来实现。功能的扩展主要由框架开发者完成，但是也可以考虑让用户能仿照异步管理数据源一样建立自己专用的数据源来解决业务专有问题。</p>\n<p>所以 Cicada 提供了框架层面的扩展机制，我们称之为 utility 工具类插件和 job 任务类插件。工具类插件也可以理解成专有数据源，与业务之间有强联系，比如 validation utility，用户只有在需要用的时候，才需要操作 validation，而框架则通过参数的方式，注入到了用户的逻辑代码当中。任务类插件 job，比如 mapBackgroundoState，是 Cicada 提供的一种数据源对组件数据映射规则，我们来看如下的例子，</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapInputToButton</span>(<span class=\"hljs-params\">{ stateTree }</span>)</span>{\n  <span class=\"hljs-keyword\">if</span> (stateTree.get(name.value) === <span class=\"hljs-string\">'alice'</span>) {\n  \t<span class=\"hljs-keyword\">return</span> {\n\t  <span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">false</span>\n\t}\n  }\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">true</span>\n  }\n}\n\nReactDom.render(\n  &lt;Render\n    stateTree={stateTree}\n    appearance={appearance}\n    background={background}\n  &gt;\n    &lt;Input bind=\"name\" /&gt;\n\t&lt;Button mapBackgroundToState={[mapInputToButton]} /&gt;\n  &lt;/Render&gt;, document.getElementById('root')\n)\n</code></pre>\n<p>用户在 mapInputToButton 方法里写映射逻辑，即如果 Input 输入框的内容为「alice」，则 Button 组件可选，如果输入框写了其他内容，Button 组件不可选。这里我们形成了一种组件数据源（Input）到组件数据源（Button）的映射关系。而一旦写好之后，用户无需关心何时触发，因为在这个方法里已经定义好了。</p>\n<h2 id=\"he2-qi2-ta1-kuang4-jia4-bi3-jiao4\">和其他框架比较</h2>\n<p>不论是 Redux 还是 Mobox，都是专门用来管理状态树的工具。 Cicada 自身除了实现了一套完备的状态树管理系统之外，更是提供了<strong>一整套的复杂前端页面系统的解决方案</strong>。换句话说，使用 Cicada 可以帮你解决了将来项目变得臃肿和庞大之后，所遇到的问题，比如有效的管理组件交互和组建数据。我们经过长时间的摸索和总结，提供了这一套解决方案。当然，由于 Cicada 构建在 React 之上，适配 React 的第三方库也同样适用于 Cicada，比如 React router，我们也提供了这样的例子。</p>\n<p>前端应用开发的最佳实践可以说种类繁多，但毫无疑问，任何一个最佳实践，都一定是为了解决具体某实际问题而存在的。面对同样的问题「如何更好的开发复杂前端应用？」，我们可以使用 React + Redux 或者其他业界认可的最佳实践来完成开发，但我们更应该选择 Cicada，毕竟这是一个经过实践沉淀的用于解决构建复杂前端页面的运行时框架（我们团队内部已经开发和使用近两年时间）。</p>\n","githubLink":"githubLikn/src/doc/how-it-works/intro.md"},"cicada-de-kuo4-zhan3-ji1-zhi4":{"title":"Cicada 的扩展机制","author":null,"index":[1,5],"group":"HOW IT WORKS","url":"cicada-de-kuo4-zhan3-ji1-zhi4","toc":[{"id":"gai4-nian4-he2-bei4-jing3","value":"概念和背景"},{"id":"cicada-dang1-zhong1-de-uitilities-he2-jobs","value":"Cicada 当中的 Uitilities 和 Jobs"},{"id":"shi3-yong4-utility","value":"使用 Utility"},{"id":"shi3-yong4-job","value":"使用 Job"},{"id":"tan4-jiu1-utility-he2-job-nei4-bu4","value":"探究 Utility 和 Job 内部"},{"id":"background","value":"Background"},{"id":"geng1-duo1","value":"更多"}],"content":"<h2 id=\"gai4-nian4-he2-bei4-jing3\">概念和背景</h2>\n<p>在框架的开发过程中，我们对常见的业务场景总结和抽象，提炼出了两个概念：Utility 和 Job。Utility 是工具类插件，让用户在开发的时候，可以借助某类 Utility 来更有效的专注于业务功能的开发，常见的工具类插件，比如验证模块 validation，提供了一整套方法来满足不同场景的需求，包括但不限于：</p>\n<ul>\n<li>支持多个组件联合校验</li>\n<li>支持异步校验</li>\n<li>支持校验数据的重置</li>\n</ul>\n<p>而 Job 是任务类插件，支持监听依赖，并且根据依赖变化自动执行任务。一旦使用了 Job，用户只需在最开始定义依赖，剩下的就交给了框架，去收集依赖，监听依赖，最后根据变化的结果，渲染页面。一个常见的使用场景是组件的显隐规则。我们只要在组件的 prop 上加入\n<code>visible={() =&gt; {return validation.isValid('xxx') }}</code>，组件的显隐与否就直接与表单验证的结果形成了强关联。只有验证通过，组件才会显示。</p>\n<p>同样的我们之前介绍过 stateTree 和 appearance 的概念，Utility 和 Job 可以在内部操作 stateTree 或者 appearance，随时获取和操作组件状态以及修改组件的样式。</p>\n<h2 id=\"cicada-dang1-zhong1-de-uitilities-he2-jobs\">Cicada 当中的 Uitilities 和 Jobs</h2>\n<p>我们在源码中，已经提供了如下的工具类和任务类插件，其中 Utility 包括：</p>\n<ul>\n<li>validation 提供了一系列表单验证的方法</li>\n<li>appearance 控制组件的显隐</li>\n<li>business 用来存储和组件状态无关的数据，通常是业务相关的数据，可以脱离组件存在，具备数据的增删减改操作</li>\n<li>form 只提供了对表单组件数据的快速集合操作，和 validation 不同，内部不保存其他状态</li>\n<li>listener 通用型的事件监听容器，用户自定义的事件和组件的默认事件都在这里被记录，具有依赖收集和监听的功能</li>\n<li>stateTree 是全局 stateTree 的代理，用来配合 mapBackgroundToState</li>\n</ul>\n<p>Job 包括：</p>\n<ul>\n<li>interpolation 用于子组件的替换</li>\n<li>mapBackgroundToState 自动修改组件状态</li>\n<li>visibility 自动运行组件的显隐规则</li>\n</ul>\n<h2 id=\"shi3-yong4-utility\">使用 Utility</h2>\n<p>Utility 是为了解决某个具体问题而存在的扩展，我们以 Validation Utility 为例，看它是如何实现表单验证的(源码在 pages/form/index.js)</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> validators = {\n  notEmpty({ state }) {\n    <span class=\"hljs-keyword\">const</span> isValid = state.value.trim() !== <span class=\"hljs-string\">''</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">type</span>: isValid ? <span class=\"hljs-string\">'success'</span> : <span class=\"hljs-string\">'error'</span>,\n      <span class=\"hljs-attr\">help</span>: isValid ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'不能为空'</span>,\n    }\n  },\n}\n...\n\n&lt;div&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>自校验<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span>\n  &lt;C.Input bind=<span class=\"hljs-string\">\"name\"</span> getInitialState={() =&gt; ({ <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'姓名'</span> })} validator={{ <span class=\"hljs-attr\">onChange</span>: [{ <span class=\"hljs-attr\">fn</span>: validators.notEmpty }] }} /&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>如上，这是一个验证输入框非空的例子。首先我们看到 Input 组件包含了一个 validator 的 prop，这是我们事先定义好的 prop，在初始化组件的时候，如果发现存在一个 validator prop，Cicada 就意识到这是一个 Validation Utility，那么相应的，就会采取 Validation 的扩展机制来处理当前组件。</p>\n<p>我们看到 validator prop 实际上是一个 JS 对象，key 为 onChange（这是 Input 自带的监听事件），value 为一个函数对象数组，数组当中的第一个对象 key 为 fn，value 是一个\b用户定义的纯函数，用来判断输入框是否为空。之所以写成这种形式，是考虑到了表单组件存在多个验证规则的情况，比如\b同时非空和字符串长度限制。</p>\n<p>在了解了组件的写法规则后我们来看用户定义的纯函数 notEmpty()，参数 state 是当前组件的状态，state.value 即为 Input 输入框的当前值，经过逻辑判断后，notEmpty() 返回了一个纯对象，该对象的结构与组件的状态保持一致（即输入框组件本身也具有 type，help 的 keys）。</p>\n<p>当用户按照 Utility 暴露的接口写好组件之后，就不需要关心剩下的操作了。被注册的 Utility 会自动判断用户输入是否为空，然后报错或者提示成功。</p>\n<h2 id=\"shi3-yong4-job\">使用 Job</h2>\n<p>同 Utility 类似，Job 也是自动运行的扩展，但和 Utility 不同的是，Job 监听的\b依赖可以是 Utility 本身。仍然以表单验证为例，我们看下 Job 是如何工作的。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">looseValidation</span>(<span class=\"hljs-params\">{ validation }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> isValid = validation.isValid(<span class=\"hljs-string\">''</span>, <span class=\"hljs-literal\">true</span>)\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">disabled</span>: !isValid }\n}\n\n&lt;C.Button getInitialState={() =&gt; ({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'弱校验'</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'primary'</span>, <span class=\"hljs-attr\">disabled</span>: <span class=\"hljs-literal\">false</span> })} mapBackgroundToState={[looseValidation]} /&gt;\n</code></pre>\n<p>上面是一个弱校验的案例， <code>mapBackgroundToState</code> 是我们引入的一个 Job 扩展，顾名思义，它通过监听 Background 的变化，最终返回相应的组件状态。同 Utility 不同，在 Button 组件中，prop mapBackgroundToState 是一个函数数组，该数组的第一个元素是用户定义的 looseValidation 函数。looseValidation() 接受 Utility validation 作为参数，validation 是实例化的 Utility，它存在一个 isValid 的属性来判断是否当前所有表单组件验证通过。假设通过，则返回对象 {disable: false}，该对象与 Button 组件的状态一致，同时 Button 组件的 disable 值也被设置为了 false。</p>\n<p>可以看到，Job 是根据监听某一个依赖而自动运行的函数。这个依赖是我们添加的 Utility 的实例化对象。</p>\n<h2 id=\"tan4-jiu1-utility-he2-job-nei4-bu4\">探究 Utility 和 Job 内部</h2>\n<p>Utility 和 Job 扩展具备了统一的数据结构，我们深入源码来探讨它们的具体作用。依然以 pages/validation/index.js 为例，直接跳到它的返回值。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initialize</span>(<span class=\"hljs-params\"></span>) </span>{\n  ...\n  return {\n    register() {},\n    <span class=\"hljs-attr\">collect</span>: collector.collect,\n    <span class=\"hljs-attr\">extract</span>: collector.extract,\n    <span class=\"hljs-attr\">subscribe</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">...arg</span>) =&gt;</span> listeners.insert(...arg),\n  }\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initialize</span>(<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">{validation}</span>) </span>{}\n</code></pre>\n<p>每一个 Utility 扩展都提供了如上的接口：</p>\n<ul>\n<li>register() 用来注册该 Utility，把组件和该 Utility 关联起来</li>\n<li>collect/extract 提供依赖计算的支持</li>\n<li>subscribe() 用来添加依赖</li>\n<li>initialize() 初始化独立的数据结构和实例，保证 Utility 内部能够保存每个组件的验证状态和验证结果</li>\n<li>test() 用来判断当前组件状态是否发生变化</li>\n<li>check() 用来判断当前组件是否需要启动相应的 Utility 扩展</li>\n</ul>\n<p>再来看 Job 扩展，以 mapBackgroundToState 为例。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initialize</span>(<span class=\"hljs-params\"></span>) </span>{\n  ...\n  return {\n    register,\n    run,\n    handle\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">{mapBackgroundToState}</span>) </span>{}\n</code></pre>\n<p>每个 Job 扩展都提供了如上的接口：</p>\n<ul>\n<li>register() 注册该 Job 扩展</li>\n<li>run() 运行所有\b注册的依赖</li>\n<li>handle() 更新状态树</li>\n<li>check() 用来判断当前组件\b是否需要启动相应的 Job 扩展</li>\n</ul>\n<p>需要注意的是，不论 Utility 或者 Job 扩展，只有 check 返回为 true 的时候，才会调用\b相应扩展，进行初始化。所以如果观察之前的组件，我们会发现组件上的 prop 名称就是 check 里面的参数，比如 validation 和 mapBackgroundToState。</p>\n<h2 id=\"background\">Background</h2>\n<p>我们可以理解 Background 是作为 Utility 和 Job 的容器而存在的。\nUtility 和 Job 暴露了统一的接口供 Background 使用。通过阅读 <code>createBackground.js</code> 源码可以发现，</p>\n<ol>\n<li>它对外提供了统一的 register 函数，这个函数是 connect 中对每个组件自动调用的。在 register 函数中在调用相关 Utility 和 Job 的 register，这样就建立了 Background 和组件的联系。</li>\n<li>提供了统一的接口来实现 Utility 和 Job 的 cancel register 等操作。</li>\n<li>当 Background 发生变化的时候，调用用户写的 mapBackgroundToState，更新状态树。</li>\n</ol>\n<p>总的来说，就是 Background 确保了 Utility 和 Job 与组件之间的联系。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> background = createBackground({\n  <span class=\"hljs-attr\">utilities</span>: {\n    <span class=\"hljs-attr\">validation</span>: validationBackground,\n    <span class=\"hljs-attr\">stateTree</span>: stateTreeBackground,\n    <span class=\"hljs-attr\">appearance</span>: appearanceBackground,\n    <span class=\"hljs-attr\">listener</span>: listenerBackground,\n  },\n  <span class=\"hljs-attr\">jobs</span>: {\n    <span class=\"hljs-attr\">mapBackgroundToState</span>: mapBackgroundToStateJob,\n    <span class=\"hljs-attr\">visible</span>: visibleJob,\n  },\n}, stateTree, appearance)\n\nReactDom.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Render</span>\n    <span class=\"hljs-attr\">stateTree</span>=<span class=\"hljs-string\">{stateTree}</span>\n    <span class=\"hljs-attr\">appearance</span>=<span class=\"hljs-string\">{appearance}</span>\n    <span class=\"hljs-attr\">background</span>=<span class=\"hljs-string\">{background}</span>\n  &gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Demo</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Render</span>&gt;</span></span>,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n)\n</code></pre>\n<h2 id=\"geng1-duo1\">更多</h2>\n<p>如果觉得 Cicada 自带的 Background 插件\b仍不能满足需求，你可以点击<a href=\"\">这里</a>了解如何开发自定义 Background 插件</p>\n","githubLink":"githubLikn/src/doc/how-it-works/utility-and-job.md"},"ji1-ben3-shi3-yong4-fang1-fa3":{"title":"基本使用方法","description":"基础教程","author":"imink","index":[0,3],"group":"QUICK START","url":"ji1-ben3-shi3-yong4-fang1-fa3","toc":[{"id":"demo","value":"Demo"},{"id":"chuan2-tong3-zu3-jian4-xie3-fa3-vs-pei4-zhi4-json-de-fang1-shi4-zhuan4-xie3-zu3-jian4","value":"传统组件写法 VS 配置JSON的方式撰写组件"},{"id":"tian1-jia1-jian1-ting1-shi4-jian4","value":"添加监听事件"},{"id":"biao3-dan1-yan4-zheng4","value":"表单验证"},{"id":"kong4-zhi4-zu3-jian4-xian3-ying3","value":"控制组件显影"}],"content":"<p>\b</p>\n<h2 id=\"demo\">Demo</h2>\n<div class='demo' id='demo-1' demo-name='helloWorldConfig' mount-name='helloWorldConfig'></div>\n<div class='demo' id='demo-2' demo-name='helloWorldDefault' mount-name='helloWorldDefault'></div>\n<h2 id=\"chuan2-tong3-zu3-jian4-xie3-fa3-vs-pei4-zhi4-json-de-fang1-shi4-zhuan4-xie3-zu3-jian4\">传统组件写法 VS 配置JSON的方式撰写组件</h2>\n<p>如上 Demo，我们提供了2种方式去打印用户输入，一种是传统的方式写组件，比如 <code>export default class Component extend React.Component {}</code> 或者 <code>const MyComp = () =&gt; (&lt;div&gt;MyComp&lt;/div&gt;)</code>，第二种为 Cicada 特有，采用 JavaScript 对象的方式写组件。我们知道，一个 HTML 页面是由树型 DOM 组成的。对于一个有经验的前端开发者，我们更喜欢手动编写页面的逻辑和样式，包括（HTML tag 的嵌套，增加监听事件），因为开发者了解具体每个组件或者说 HTML tag 的用法。而对于非前端开发者，去了解每一个组件或者 tag 的用法的成本是很高的，用户会倾向于所见即所得的方式去构建页面，对于简单的页面，这实现起来非常简单，但是对于复杂页面（不仅仅是展示页面，同时也需要一定的交互能力和数据操作能力），更具灵活性的配置方式会更受用户青睐。</p>\n<p>一个典型的例子如下，我们定义了一个 Button 组件：</p>\n<pre class=\"hljs\"><code>{\n  type: 'div',\n  children: [{\n    type: 'Button',\n    getInitialState: () =&gt; ({\n      text: '测试按钮'\n    }）,\n    children: []\n  }]\n}\n</code></pre>\n<h3 id=\"config\">config</h3>\n<p>config是一个普通的js对象，页面组件的每一项功能都对应一项配置，下面讲解config的结构。</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'div'</span>,\n  <span class=\"hljs-attr\">children</span>: []\n}\n</code></pre>\n<p>最简单的config结构如上所示，type代表组件类型，children表示这个组件的孩子节点，也就是这个组件的子组件，页面通过以div组件为根节点形成一颗组件树。</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'div'</span>,\n  <span class=\"hljs-attr\">children</span>: [{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Button'</span>,\n    <span class=\"hljs-attr\">children</span>: []\n  }]\n}\n</code></pre>\n<p>如上所示，div下面有个Button组件，这样递归的方式就可以形成一颗完整的组件树，其中type可以是我们提供的任何组件，这里就是组件名。</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'div'</span>,\n  <span class=\"hljs-attr\">children</span>: [{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Button'</span>,\n    <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'测试按钮'</span>\n    }),\n    <span class=\"hljs-attr\">children</span>: []\n  }]\n}\n</code></pre>\n<p>如上所示，组件的属性配置就是在一个props对象上面，直接配置即可，没有bind值的是在props上配置，如果组件有bind值，则是在initialState上配置，如下所示</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'div'</span>,\n  <span class=\"hljs-attr\">children</span>: [{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Button'</span>,\n    <span class=\"hljs-attr\">initialState</span>: {\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'测试按钮'</span>\n    },\n    <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-string\">'btn'</span>,\n    <span class=\"hljs-attr\">children</span>: []\n  }]\n}\n</code></pre>\n<p>组件的事件配置如下所示</p>\n<pre class=\"hljs\"><code>{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'div'</span>,\n  <span class=\"hljs-attr\">children</span>: [{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Button'</span>,\n    <span class=\"hljs-attr\">initialState</span>: {\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'测试按钮'</span>\n    },\n    <span class=\"hljs-attr\">listeners</span>: {\n      <span class=\"hljs-attr\">onClick</span>: {\n        <span class=\"hljs-attr\">fns</span>: [{\n          fn({ store }) {\n            <span class=\"hljs-built_in\">console</span>.log(store)\n          }\n        }]\n      }\n    },\n    <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-string\">'btn'</span>,\n    <span class=\"hljs-attr\">children</span>: []\n  }]\n}\n</code></pre>\n<p>组件事件配置都在listeners配置项里，onClick是这个组件支持的事件类型，fns代表组件绑定的事件响应逻辑数组，因为能够绑定多个逻辑，所以这里是个数组，多个逻辑按照数组顺序串行执行。每个数组元素是个带有fn键的对象，其中fn是个函数，表示事件触发执行的真正逻辑</p>\n<h3 id=\"xie3-fa3-bu4-tong2-dan4-ben3-zhi4-xiang1-tong2\">写法不同，但本质相同</h3>\n<p>关于用 config 配置的方式写组件的原因，我们会在<a href=\"\">这里</a>具体说明。但是就具体实现的效果，其实两种方式都可以实现同样的页面。你会发现，可能你更倾向使用传统的方式，因为写具有嵌套的配置 config 没有默认写法直观，代码量也更多些。接下来，本文不会继续讨论关于这两种写法的探究，而是重点介绍，Cicada 究竟能做什么，或者说，擅长做什么。</p>\n<h2 id=\"tian1-jia1-jian1-ting1-shi4-jian4\">添加监听事件</h2>\n<h2 id=\"biao3-dan1-yan4-zheng4\">表单验证</h2>\n<h2 id=\"kong4-zhi4-zu3-jian4-xian3-ying3\">控制组件显影</h2>\n<p>组件的显影和组件的数据操作完全不同。数据操作逻辑是主动式的代码, 通过 stateTree.set 来进行设置。显影的逻辑是被动式的, 根据数据来 return true 或者 false, 由框架自动刷新。</p>\n<h3 id=\"she4-ji4-yuan2-yin1\">设计原因</h3>\n<ul>\n<li>增强代码可维护性\n大部分显隐场景都是联动状态, 比如 select 选中了某个选项, 下面的另一个组件就隐藏或者显示。试想如果我们的代码是主动式的, 在 select 的 onChange 事件中去主动设置下面组件的显隐, 当我们将业务转交给其他人, 或者很久之后自己再来维护个页面而忘记了这个逻辑的时候。我们要一个一个逻辑去找看哪个里面触发了显隐。 而且还要立即其中的逻辑代码, 才能知道为什么要显示或者隐藏。\n相反,用被动式的逻辑, 我们可以很肯定的直接找到显隐组件的显隐逻辑。可以很直观的了解到这个组件在什么样的数据下就显示或者隐藏。绝大部分情况下和我们的业务逻辑也是贴合的。</li>\n<li>更易于使用组合显隐规则\n试想一个组件的显隐是由多个组件的数据控制的, 那么用主动式的代码我们需要在相关组件的 onChange 事件中都去控制该组件。而用被动式 的规则则始终只用关注数据, 逻辑写在该组件中就够了。</li>\n</ul>\n<h3 id=\"shi3-yong4\">使用</h3>\n<p>Cicada 提供了 visibility 的 job 来根据用户需求自动实现显影，只要在组件上加入 visible 的属性，通过判断返回 true/false 实现显影。也就是说，我们可以在 visible 属性加入含有 stateTree 的逻辑代码，就可以和页面的其他组件产生联系。从而实现复杂的显影规则。具体可以参考 EXAMPLE 当中的。。。\u001b</p>\n","githubLink":"githubLikn/src/doc/quick-start/basic-usage.md"},"kai1-shi3-zhi1-qian2":{"title":"开始之前","description":"基础教程","author":"imink","index":[0,1],"group":"QUICK START","url":"kai1-shi3-zhi1-qian2","toc":[{"id":"react-redux-yi3-ji2-mobx","value":"React, Redux 以及 Mobx"},{"id":"jsx-yu3-fa3","value":"JSX 语法 \b"},{"id":"es6-yu3-fa3","value":"ES6 语法"}],"content":"<p>Cicada.js 不是一个凭空制造的基于 React 的框架，虽然你完全可以按照 React 的写法去写 Cicada 程序，但是我们赋予了 Cicada 应对更复杂的应用场景的能力。</p>\n<h2 id=\"react-redux-yi3-ji2-mobx\">React, Redux 以及 Mobx</h2>\n<p>在正式使用 Cicada 之前，我们建议你已经掌握了 React 的基本用法，包括组件的写法，state 和 props 的概念。\n对于 <a href=\"http://redux.js.org/\">Redux</a>，我们希望你已经了解单向数据流的概念，以及全局 state tree 的优势和好处。\n对于 <a href=\"https://github.com/mobxjs/mobx\">Mobx</a>，我们希望你可以了解 mobx 的<a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">消息订阅者模式</a>，Cicada.js 也采用了消息订阅者模式来完成\b事件的监听和触发，\b我们也实现了精确定位和更新，同时最大程度的减少了额外的开销。</p>\n<h2 id=\"jsx-yu3-fa3\">JSX 语法 \b</h2>\n<p><a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\">JSX</a> 是 React 提出的一种基于 JavaScript 的语法，它能够混写 JS 和 HTML，\b灵活方便的实现一些复杂的页面结构。</p>\n<h2 id=\"es6-yu3-fa3\">ES6 语法</h2>\n<p>项目基于 JavaScript ES2015 版本开发，我们建议使用 Babel 来编译 JSX 和 ES6 语法。</p>\n","githubLink":"githubLikn/src/doc/quick-start/before-you-start.md"},"xiang4-mu4-kai1-shi3":{"title":"项目开始","description":"基础教程","author":"imink","index":[0,2],"group":"QUICK START","url":"xiang4-mu4-kai1-shi3","toc":[{"id":"an1-zhuang1-cicada","value":"安装 Cicada"},{"id":"xie3-yi1-ge4-hello-word-cheng2-xu4","value":"写一个 Hello Word 程序"},{"id":"wo3-men2-yin3-ru4-liao3-na3-xie1-bian4-liang2-ta1-men2-fen1-bie2-you3-shi2-mo2-zuo4-yong4","value":"\b我们引入了哪些变量，他们分别有什么作用"},{"id":"shi2-mo2-shi4-react-lego-zu3-jian4-gui1-fan4","value":"什么是 React Lego 组件规范"},{"id":"liao3-jie3-geng1-duo1","value":"\b了解更多"},{"id":"wei4-lai2","value":"未来"}],"content":"<h2 id=\"an1-zhuang1-cicada\">安装 Cicada</h2>\n<p>\b安装之前确保系统已经安装了最新的 Node.js 以及 NPM，如果你还没有安装，请前往<a href=\"https://www.npmjs.com/get-npm\">这里</a>。</p>\n<p>接下来，打开命令行工具，输入：</p>\n<p><code>npm install --save @cicada/render</code></p>\n<p>安装核心的引擎模块。你就可以写一些简单的程序了。因为 Cicada 应用于\b React Lego 组件，你可以来<a href=\"\">这里</a> 找到我们提供的 antd UI 组件，或者也可以按照 <a href=\"https://github.com/cicada-team/react-lego\">React Lego 规范</a> 来根据需求编写组件。</p>\n<p>如果想直接\b动手把玩，可以查阅 pages 下更多 demo 源码。</p>\n<h2 id=\"xie3-yi1-ge4-hello-word-cheng2-xu4\">写一个 Hello Word 程序</h2>\n<p>在安装完 cicada 之后，\b我们可以通过一个 \b\bHello World 程序，来认识一下常用的代码结构。因为 cicada 构建在 React 之上，我们完全可以按照 React 的方式来写 Hello Word 程序。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> ReactDom form <span class=\"hljs-string\">'react-dom'</span>\nReactDOM.render( <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Hello World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>, <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>))\n</code></pre>\n<p>没错，这可以说是最简单的 React 用法了。接下来我们把 Cicada  的相关依赖导入，认识一下标准的 Cicada 程序写法。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>\n<span class=\"hljs-keyword\">import</span> connect <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/connect'</span>\n<span class=\"hljs-keyword\">import</span> { mapValues } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/util'</span>\n<span class=\"hljs-keyword\">import</span> Render <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/Render'</span>\n<span class=\"hljs-keyword\">import</span> createStateTree <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/createStateTree'</span>\n<span class=\"hljs-keyword\">import</span> createAppearance <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/createAppearance'</span>\n<span class=\"hljs-keyword\">import</span> createBackground <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/createBackground'</span>\n<span class=\"hljs-keyword\">import</span> applyStateTreeSubscriber <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/applyStateTreeSubscriber'</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> validationBackground <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/background/utility/validation'</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> stateTreeBackground <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/background/utility/stateTree'</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> appearanceBackground <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/background/utility/appearance'</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> mapBackgroundToStateJob <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/background/job/mapBackgroundToState'</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> visibleJob <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@cicada/render/lib/background/job/visibility'</span>\n<span class=\"hljs-comment\">// 引入 React Lego 组件</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> Input <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Input'</span> \n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> Button <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Button'</span>\n\n\n<span class=\"hljs-keyword\">const</span> C = mapValues({ Input, Button }, connect)\n<span class=\"hljs-keyword\">const</span> stateTree = applyStateTreeSubscriber(createStateTree)()\n<span class=\"hljs-keyword\">const</span> appearance = createAppearance()\n<span class=\"hljs-keyword\">const</span> background = createBackground()\n\n<span class=\"hljs-built_in\">window</span>.stateTree = stateTree\nReactDOM.render(\n  &lt;Render\n    stateTree={stateTree}\n    appearance={appearance}\n    background={background}\n  &gt;\n  &lt;C.Input /&gt;\n  &lt;C.Button /&gt;\n  &lt;/Render&gt;,\n  document.getElementById('mount'),\n)\n</code></pre>\n<!--<div id=\"demo-1\">这里挂载 snippet playground</div>-->\n<p>代码变多了起来是不是？当然，Cicada 本身不是用来处理的简单的页面渲染，我们在组件的基础之上，通过 Cicada 引擎赋予了组件更多的能力，\b通过组件本身暴露的状态的事件，让用户实现更多复杂的效果和需求。</p>\n<h2 id=\"wo3-men2-yin3-ru4-liao3-na3-xie1-bian4-liang2-ta1-men2-fen1-bie2-you3-shi2-mo2-zuo4-yong4\">\b我们引入了哪些变量，他们分别有什么作用</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> C = mapValues({ Input, Button }, connect)\n</code></pre>\n<p>首先我们看第一句，这里的 connect 实际上\b是用来封装我们的组件 Input, Button，赋予了组件一系列的特性，我们稍后会提到 connect 的具体原理。mapValues(object, function) 是一个 \butility 方法， 第一个参数是\b组件对象，第二个参数是 connect 方法，轮询组件对象里面的每一个组件，同时运行一次 connect(component) 方法，最后返回一个封装过的组件对象。之后可以通过 <code>&lt;C.Input /&gt;</code> 来声明一个组件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> stateTree = applyStateTreeSubscriber(createStateTree)()\n<span class=\"hljs-keyword\">const</span> appearance = createAppearance() <span class=\"hljs-comment\">// 页面状态相关</span>\n<span class=\"hljs-keyword\">const</span> background = createBackground() <span class=\"hljs-comment\">// 页面监听事件</span>\n</code></pre>\n<p>stateTree 是全局唯一的状态树，程序的状态数据（组件 UI 状态比如勾选框的 check 属性，组件的内部状态比如 a 标签的 href 值）都是通过 stateTree 来操作。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">window</span>.stateTree = stateTree\nReactDOM.render(\n  &lt;Render\n    stateTree={stateTree}\n    appearance={appearance}\n    background={background}\n  &gt;\n  &lt;C.Input /&gt;\n  &lt;C.Button /&gt;\n  &lt;/Render&gt;,\n  document.getElementById('mount'),\n)\n</code></pre>\n<p>我们在组件的父级加上了自定义的 Rende\br 方法（根节点），同时传入了 stateTree、appearance、background 作为 props。这里是改写了 React \b的 Render 方法，把组件的 Render 控制权交给引擎。这么做的好处是可以配合之前 connect 过的组件，在渲染的时候，真正利用到 connect 过的组件的特性（之前 connect 只是声明了必要的方法，而 R\bender 才是真正执行渲染）</p>\n<p>一个简单的 Cicada 程序至少包括了\b以上几个部分。但是 Cicada 本身可以做更多。接下来我们\b会简单介绍构建 Cicada 程序的基石：<strong>React Lego 组件</strong></p>\n<h2 id=\"shi2-mo2-shi4-react-lego-zu3-jian4-gui1-fan4\">什么是 React Lego 组件规范</h2>\n<p>React Lego 组件规范是\b我们用来写适用于 Cicada 程序所共同遵循的一种方法。例如一个 Input 输入框，传统的 React 写法可以以 <code>const Input = () =&gt; {\u001b}</code> 的形式或者 <code>export default class Input extends Component</code> 的\b标准形式来写，其中包含了组件需要的 state 以及 props 还有一系列监听事件和生命周期函数，最后通过 Render 函数来完成组件的渲染。 React Lego 组件规范构建于传统的写法之上，暴露了更多的 state 和 props 以及更多可能用到的监听事件，通过 <code>export const</code> 提供给父级组件，\b通过父级组件来完成对内部状态的更新和操作。我们把内部状态暴露出来的组件称之为受控组件，把内部状态未暴露出来的组件称之为非受控组件。在一个较为复杂的应用场景下（比如联级验证），组件之间的状态是相互影响的。我们希望可以把对组件的控制权在一个统一的地方来管理，所以我们用到了全局的状态树，配合 React Lego 组件，使得组件与状态树绑定，我们就\b可以尽可能得细粒度来掌控组件。</p>\n<h2 id=\"liao3-jie3-geng1-duo1\">\b了解更多</h2>\n<h2 id=\"wei4-lai2\">未来</h2>\n<p>我们在不久的未来会推出基于 Cicada.js 的在线编辑器 Cicada IDE。Cicada.js 所具备的种种特性，包括 React Lego 组件规范，通过配置的方式编写组件，以及具备可扩展性的 Background 插件市场，使得不具备前端开发经验的用户也能够构建高度定制化的 CMS 页面，这就是我们孕育了很久的 Cicada IDE。敬请期待。</p>\n","githubLink":"githubLikn/src/doc/quick-start/get-started.md"}}